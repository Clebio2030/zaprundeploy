{"ast":null,"code":"import React,{useState,useRef,useEffect}from\"react\";import{makeStyles}from\"@material-ui/core/styles\";import{IconButton,Typography,LinearProgress,Box}from\"@material-ui/core\";import PlayArrowIcon from\"@material-ui/icons/PlayArrow\";import PauseIcon from\"@material-ui/icons/Pause\";import AudiotrackIcon from\"@material-ui/icons/Audiotrack\";const useStyles=makeStyles(theme=>({audioContainer:{display:\"flex\",flexDirection:\"column\",width:\"100%\",maxWidth:250,backgroundColor:\"transparent\",borderRadius:8,padding:theme.spacing(0.5),border:\"none\",overflow:\"hidden\"},playerControls:{display:\"flex\",alignItems:\"center\",backgroundColor:theme.palette.type===\"dark\"?\"rgba(60, 60, 60, 0.7)\":\"rgba(255, 255, 255, 0.7)\",borderRadius:24,padding:theme.spacing(0.5),boxShadow:\"0px 1px 3px rgba(0, 0, 0, 0.08)\"},playButton:{padding:6,color:theme.palette.primary.main},progressContainer:{display:\"flex\",flexDirection:\"column\",flex:1,marginLeft:theme.spacing(1),marginRight:theme.spacing(1)},progressBar:{height:4,borderRadius:2,marginBottom:4,backgroundColor:\"rgba(0, 0, 0, 0.1)\",\"& .MuiLinearProgress-bar\":{backgroundColor:theme.palette.primary.main}},timeInfo:{display:\"flex\",justifyContent:\"space-between\",alignItems:\"center\"},timeText:{fontSize:10,color:theme.palette.text.secondary,fontWeight:500},audioIcon:{fontSize:20,color:theme.palette.primary.main,marginRight:theme.spacing(1)}}));const formatTime=seconds=>{// Verificar se o valor é válido\nif(seconds===undefined||seconds===null||!isFinite(seconds)||isNaN(seconds)){return\"00:00\";}// Garantir que seja um número positivo\nconst safeSeconds=Math.max(0,Number(seconds));const mins=Math.floor(safeSeconds/60);const secs=Math.floor(safeSeconds%60);return\"\".concat(mins.toString().padStart(2,\"0\"),\":\").concat(secs.toString().padStart(2,\"0\"));};const getFullUrl=url=>{if(!url)return\"\";// Se a URL já começa com http ou https, retornar como está\nif(url.startsWith('http://')||url.startsWith('https://')){return url;}// Se a URL é relativa, adicionar o endereço do backend\nconst BACKEND_URL=process.env.REACT_APP_BACKEND_URL||window.location.origin;// Se começa com '/', removemos a barra para evitar duplicação\nconst cleanUrl=url.startsWith('/')?url.substring(1):url;// Verificar se já contém o prefixo public/ antes de adicioná-lo\nconst urlWithPublic=cleanUrl.startsWith('public/')?cleanUrl:\"public/\".concat(cleanUrl);// Construir a URL completa\nlet fullUrl=\"\".concat(BACKEND_URL,\"/\").concat(urlWithPublic);// Para iOS, adicionar parâmetro de timestamp para evitar cache\nif(/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream){fullUrl=\"\".concat(fullUrl,\"?t=\").concat(new Date().getTime());}console.log('[DEBUG AUDIO URL]',{original:url,final:fullUrl});return fullUrl;};// Tenta várias estratégias para construir URLs de áudio\nconst tryAlternativeUrls=url=>{if(!url)return[];// URL original\nconst originalUrl=getFullUrl(url);// URL alternativas para tentar em caso de falha\nconst alternatives=[originalUrl];// Se é um dispositivo iOS, tentar outras variações de URL\nif(isIOS){// Variar os caminhos public/ e arquivo/ que são comuns em uploads\nif(url.includes('public/')){const withoutPublic=url.replace('public/','');alternatives.push(getFullUrl(withoutPublic));}else{alternatives.push(getFullUrl(\"arquivo/\".concat(url)));}// Para URLs absolutas, adicionar variações\nif(url.startsWith('http')){// Tentar versão com e sem cache busting\nalternatives.push(\"\".concat(url,\"?t=\").concat(new Date().getTime()));// Tentar versão com protocolo alternativo (http<->https)\nif(url.startsWith('https:')){alternatives.push(url.replace('https:','http:'));}else if(url.startsWith('http:')){alternatives.push(url.replace('http:','https:'));}}}return alternatives;};// Detecta se é um dispositivo iOS\nconst isIOS=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream;console.log('[DEBUG] Dispositivo iOS detectado:',isIOS);// Função para tentar reproduzir áudio em iOS\nconst attemptIOSAudioPlay=async(audioElement,urls)=>{console.log('[DEBUG] Tentando reprodução específica para iOS');for(let i=0;i<urls.length;i++){const url=urls[i];console.log(\"[DEBUG] Tentativa \".concat(i+1,\"/\").concat(urls.length,\" com URL: \").concat(url));// Configurar o elemento de áudio para cada tentativa\naudioElement.src=url;audioElement.load();try{// Tentar reproduzir com este URL\nawait audioElement.play();console.log('[DEBUG] Reprodução bem-sucedida no iOS!');return true;}catch(error){console.error(\"[DEBUG] Falha na tentativa \".concat(i+1,\" para iOS:\"),error.message);// Se for o último URL, falhar\nif(i===urls.length-1){throw error;}// Pausar antes de tentar outro URL\ntry{audioElement.pause();}catch(e){}// Esperar um momento antes da próxima tentativa\nawait new Promise(resolve=>setTimeout(resolve,300));}}throw new Error('Todas as tentativas falharam');};export default function ChatAudioPlayer(_ref){let{audioUrl,duration,isRight}=_ref;const classes=useStyles();const[isPlaying,setIsPlaying]=useState(false);const[currentTime,setCurrentTime]=useState(0);const[audioDuration,setAudioDuration]=useState(duration||0);const[metadataLoaded,setMetadataLoaded]=useState(false);const[loadingFailed,setLoadingFailed]=useState(false);const[currentUrlIndex,setCurrentUrlIndex]=useState(0);const audioRef=useRef(null);const progressInterval=useRef(null);const loadAttempts=useRef(0);const alternativeUrls=useRef([]);const audioContext=useRef(null);// Sempre que a duração for definida diretamente via prop, considerar os metadados como carregados\nuseEffect(()=>{const validDuration=validateDuration(duration);if(validDuration>0){console.log(\"[DEBUG] Prop de dura\\xE7\\xE3o v\\xE1lida recebida: \".concat(validDuration,\"s\"));setAudioDuration(validDuration);setMetadataLoaded(true);}else if(audioDuration>0){// Se já temos uma duração válida no estado, considerar os metadados como carregados\nsetMetadataLoaded(true);}},[duration,audioDuration]);// Validar duração para garantir valor numérico válido\nconst validateDuration=value=>{// Verificar se o valor é numérico e finito\nif(value===undefined||value===null||!isFinite(value)||isNaN(value)||value<=0){return 0;}return parseFloat(value);};// Tentar pré-carregar os metadados do áudio para obter a duração correta\nuseEffect(()=>{const loadAudioMetadata=async()=>{try{// Se já temos uma duração válida, não precisamos carregar os metadados\nif(audioDuration>0){setMetadataLoaded(true);return;}// Evitar tentativas infinitas\nif(loadAttempts.current>=3){console.warn('[WARN] Número máximo de tentativas de carregamento atingido');setMetadataLoaded(true);// Para não mostrar \"Carregando...\" infinitamente\nsetLoadingFailed(true);return;}loadAttempts.current+=1;const fullUrl=getFullUrl(audioUrl);console.log('[DEBUG] Pré-carregando metadados do áudio:',fullUrl);// Tentar métodos diferentes para obter a duração\ntry{// Usar Promise.race com diferentes estratégias\nconst result=await Promise.race([// Método 1: Carregamento direto via elemento Audio\ngetDurationFromAudioElement(fullUrl),// Método 2: Usando AudioContext (pode ser mais preciso para alguns formatos)\ngetDurationFromAudioContext(fullUrl),// Timeout para não ficar esperando para sempre\nnew Promise(resolve=>setTimeout(()=>resolve({success:false,reason:'timeout'}),5000))]);if(result.success&&result.duration){const validDuration=validateDuration(result.duration);if(validDuration>0){console.log('[DEBUG] Duração válida obtida:',validDuration);setAudioDuration(validDuration);setMetadataLoaded(true);}else{throw new Error(\"Duração obtida mas com valor inválido\");}}else{throw new Error(\"Falha ao obter duração: \"+(result.reason||\"desconhecida\"));}}catch(metadataError){console.warn('[WARN] Erro ao obter metadados:',metadataError);// Tentar o método tradicional como fallback\nconst tempAudio=new Audio();// Criar uma promise que resolve quando os metadados estiverem carregados\nawait new Promise((resolve,reject)=>{const onLoadedMetadata=()=>{// Verificar se a duração é válida\nconst validDuration=validateDuration(tempAudio.duration);if(validDuration>0){console.log('[DEBUG] Duração obtida no método tradicional:',validDuration);setAudioDuration(validDuration);setMetadataLoaded(true);resolve();}else{console.warn('[WARN] Duração inválida obtida no método tradicional:',tempAudio.duration);// Usar uma duração padrão razoável (30s) \nsetAudioDuration(30);setMetadataLoaded(true);resolve();}};const onError=error=>{console.error('[ERROR] Erro no método tradicional:',error);// Em caso de erro, usar um valor padrão razoável\nsetAudioDuration(30);setMetadataLoaded(true);setLoadingFailed(true);resolve();};// Timeout para não travar o processo\nconst timeout=setTimeout(()=>{console.warn('[WARN] Timeout no método tradicional');tempAudio.removeEventListener('loadedmetadata',onLoadedMetadata);tempAudio.removeEventListener('error',onError);setAudioDuration(30);setMetadataLoaded(true);setLoadingFailed(true);resolve();},3000);tempAudio.addEventListener('loadedmetadata',()=>{clearTimeout(timeout);onLoadedMetadata();});tempAudio.addEventListener('error',e=>{clearTimeout(timeout);onError(e);});tempAudio.preload='metadata';tempAudio.src=fullUrl;tempAudio.load();});}}catch(error){console.error('[ERROR] Exceção geral ao carregar áudio:',error);// Usar uma duração padrão para não deixar o usuário sem feedback\nsetAudioDuration(30);setMetadataLoaded(true);setLoadingFailed(true);}};if(audioUrl){loadAudioMetadata();}else{// Se não houver URL, marcar como carregado para não mostrar \"Carregando...\" infinitamente\nsetMetadataLoaded(true);}// Limpar intervalo quando componente desmontar\nreturn()=>{if(progressInterval.current){clearInterval(progressInterval.current);}if(audioRef.current){audioRef.current.pause();}};},[audioUrl,audioDuration]);// Implementar método para obter duração via elemento Audio\nconst getDurationFromAudioElement=url=>{return new Promise(resolve=>{const audio=new Audio();const onLoadedMetadata=()=>{const validDuration=validateDuration(audio.duration);if(validDuration>0){console.log(\"[DEBUG] Dura\\xE7\\xE3o via Audio element: \".concat(validDuration,\"s\"));resolve({success:true,duration:validDuration});}else{console.warn(\"[WARN] Audio element retornou dura\\xE7\\xE3o inv\\xE1lida: \".concat(audio.duration));resolve({success:false,reason:'invalid_duration'});}};const onCanPlayThrough=()=>{const validDuration=validateDuration(audio.duration);if(validDuration>0){console.log(\"[DEBUG] Dura\\xE7\\xE3o via canplaythrough: \".concat(validDuration,\"s\"));resolve({success:true,duration:validDuration});}};const onError=e=>{console.error(\"[ERROR] Erro ao carregar via Audio element:\",e);resolve({success:false,reason:'audio_error'});};// Configurar timeouts e listeners\nconst timeout=setTimeout(()=>{console.warn(\"[WARN] Timeout ao carregar via Audio element\");audio.removeEventListener('loadedmetadata',onLoadedMetadata);audio.removeEventListener('canplaythrough',onCanPlayThrough);audio.removeEventListener('error',onError);resolve({success:false,reason:'timeout'});},4000);audio.addEventListener('loadedmetadata',()=>{clearTimeout(timeout);onLoadedMetadata();});audio.addEventListener('canplaythrough',()=>{clearTimeout(timeout);onCanPlayThrough();});audio.addEventListener('error',e=>{clearTimeout(timeout);onError(e);});audio.preload='metadata';audio.src=url;audio.load();});};// Implementar método para obter duração via AudioContext\nconst getDurationFromAudioContext=url=>{return new Promise(resolve=>{try{// Verificar se o navegador suporta AudioContext\nif(!window.AudioContext&&!window.webkitAudioContext){return resolve({success:false,reason:'no_audio_context'});}const AudioCtx=window.AudioContext||window.webkitAudioContext;const context=new AudioCtx();const request=new XMLHttpRequest();request.open('GET',url,true);request.responseType='arraybuffer';request.onload=()=>{context.decodeAudioData(request.response,buffer=>{const duration=buffer.duration;const validDuration=validateDuration(duration);if(validDuration>0){console.log(\"[DEBUG] AudioContext obteve dura\\xE7\\xE3o: \".concat(validDuration,\"s\"));resolve({success:true,duration:validDuration});}else{console.warn(\"[WARN] AudioContext retornou dura\\xE7\\xE3o inv\\xE1lida: \".concat(duration));resolve({success:false,reason:'invalid_duration'});}context.close();},error=>{console.error('[ERROR] Erro ao decodificar via AudioContext:',error);resolve({success:false,reason:'decode_error'});context.close();});};request.onerror=error=>{console.error('[ERROR] Erro na requisição XHR para AudioContext:',error);resolve({success:false,reason:'xhr_error'});context.close();};// Timeout para não esperar indefinidamente\nsetTimeout(()=>{if(request.readyState!==4){request.abort();context.close();resolve({success:false,reason:'timeout'});}},4000);request.send();}catch(error){console.error('[ERROR] Exceção ao usar AudioContext:',error);resolve({success:false,reason:'context_exception'});}});};// Função para reprodução compativel com iOS\nconst togglePlayback=async()=>{// Se estiver tocando, apenas pause\nif(isPlaying){console.log('[DEBUG] Pausando reprodução atual');audioRef.current.pause();clearInterval(progressInterval.current);setIsPlaying(false);return;}// Primeira vez inicializando o player\nif(!audioRef.current){// Gerar todas as URLs alternativas na primeira vez\nif(alternativeUrls.current.length===0){alternativeUrls.current=tryAlternativeUrls(audioUrl);console.log(\"[DEBUG] URLs alternativas geradas:\",alternativeUrls.current);}console.log(\"[DEBUG] Inicializando player de \\xE1udio com \".concat(alternativeUrls.current.length,\" URLs alternativas\"));audioRef.current=new Audio();// Configurar o contexto de áudio para iOS, necessário para desbloquear o áudio\nif(isIOS&&!audioContext.current){try{const AudioCtx=window.AudioContext||window.webkitAudioContext;audioContext.current=new AudioCtx();// Executar uma oscilação silenciosa para \"desbloquear\" o áudio no iOS\nconst oscillator=audioContext.current.createOscillator();const gainNode=audioContext.current.createGain();gainNode.gain.value=0.01;// Quase silencioso\noscillator.connect(gainNode);gainNode.connect(audioContext.current.destination);oscillator.start(0);oscillator.stop(0.1);console.log('[DEBUG] Contexto de áudio inicializado para iOS');}catch(error){console.warn('[WARN] Erro ao inicializar contexto de áudio:',error);}}// Adicionar atributos para melhor compatibilidade com iOS\nif(isIOS){audioRef.current.setAttribute('playsinline','true');audioRef.current.setAttribute('webkit-playsinline','true');audioRef.current.setAttribute('preload','auto');audioRef.current.setAttribute('controls','true');audioRef.current.muted=false;}// Adicionar tratamento de eventos\naudioRef.current.addEventListener(\"loadedmetadata\",()=>{console.log(\"[DEBUG] Metadados carregados. Dura\\xE7\\xE3o: \".concat(audioRef.current.duration,\"s\"));const validDuration=validateDuration(audioRef.current.duration);if(validDuration>0){setAudioDuration(validDuration);setMetadataLoaded(true);}else{// Mesmo com duração inválida, marcar como carregado\nsetMetadataLoaded(true);}});audioRef.current.addEventListener(\"ended\",()=>{console.log('[DEBUG] Reprodução finalizada');setIsPlaying(false);setCurrentTime(0);clearInterval(progressInterval.current);});audioRef.current.addEventListener(\"error\",e=>{const errorCode=audioRef.current.error?audioRef.current.error.code:'Desconhecido';const errorMessage=audioRef.current.error?audioRef.current.error.message:'Erro desconhecido';console.error(\"[ERROR] Falha ao carregar \\xE1udio: Codigo \".concat(errorCode,\" - \").concat(errorMessage));console.error(\"[ERROR] URL que falhou: \".concat(audioRef.current.src));// Tentar próxima URL alternativa se disponível\nif(currentUrlIndex<alternativeUrls.current.length-1){console.log(\"[DEBUG] Tentando pr\\xF3xima URL alternativa (\".concat(currentUrlIndex+1,\")\"));setCurrentUrlIndex(currentUrlIndex+1);audioRef.current.src=alternativeUrls.current[currentUrlIndex+1];audioRef.current.load();// Não marcar como falha ainda, estamos tentando outra URL\n}else{if(isIOS){window.alert('Não foi possível reproduzir este áudio no iOS. Toque na tela e tente novamente ou use outro dispositivo.');}else{window.alert('Não foi possível reproduzir o áudio. Verifique a conexão ou tente novamente mais tarde.');}setLoadingFailed(true);}});// Inicialmente, usar a primeira URL alternativa\naudioRef.current.src=alternativeUrls.current[currentUrlIndex];audioRef.current.load();}else if(isIOS){// Para iOS: Se já temos um elemento de áudio e estamos tentando reproduzir novamente\nconsole.log('[DEBUG] Tentando reproduzir novamente no iOS - recarregando áudio');// Resetar completamente o elemento de áudio para iOS\ntry{// Parar qualquer reprodução em andamento\naudioRef.current.pause();// Descarregar qualquer conteúdo\naudioRef.current.removeAttribute('src');audioRef.current.load();// Resetar a posição\naudioRef.current.currentTime=0;// Remover todos os event listeners existentes para evitar duplicação\nconst oldAudio=audioRef.current;audioRef.current=new Audio();// Transferir atributos importantes\naudioRef.current.setAttribute('playsinline','true');audioRef.current.setAttribute('webkit-playsinline','true');audioRef.current.setAttribute('preload','auto');audioRef.current.setAttribute('controls','true');audioRef.current.muted=false;// Recriar eventos\naudioRef.current.addEventListener(\"loadedmetadata\",()=>{console.log(\"[DEBUG] Metadados carregados. Dura\\xE7\\xE3o: \".concat(audioRef.current.duration,\"s\"));const validDuration=validateDuration(audioRef.current.duration);if(validDuration>0){setAudioDuration(validDuration);setMetadataLoaded(true);}else{setMetadataLoaded(true);}});audioRef.current.addEventListener(\"ended\",()=>{console.log('[DEBUG] Reprodução finalizada');setIsPlaying(false);setCurrentTime(0);clearInterval(progressInterval.current);});audioRef.current.addEventListener(\"error\",e=>{const errorCode=audioRef.current.error?audioRef.current.error.code:'Desconhecido';const errorMessage=audioRef.current.error?audioRef.current.error.message:'Erro desconhecido';console.error(\"[ERROR] Falha ao carregar \\xE1udio: Codigo \".concat(errorCode,\" - \").concat(errorMessage));console.error(\"[ERROR] URL que falhou: \".concat(audioRef.current.src));// Tentar próxima URL alternativa se disponível\nif(currentUrlIndex<alternativeUrls.current.length-1){console.log(\"[DEBUG] Tentando pr\\xF3xima URL alternativa (\".concat(currentUrlIndex+1,\")\"));setCurrentUrlIndex(currentUrlIndex+1);audioRef.current.src=alternativeUrls.current[currentUrlIndex+1];audioRef.current.load();}else{window.alert('Erro ao reproduzir no iOS. Verifique as configurações de som e tente novamente.');setLoadingFailed(true);}});// Recarregar com URL com timestamp para evitar problemas de cache no iOS\nconst currentUrl=alternativeUrls.current[currentUrlIndex];const refreshedUrl=\"\".concat(currentUrl.split('?')[0],\"?t=\").concat(new Date().getTime());console.log('[DEBUG] Recarregando com URL atualizada para segundo play:',refreshedUrl);audioRef.current.src=refreshedUrl;audioRef.current.load();// Limpar sinalizadores de erro\nsetLoadingFailed(false);}catch(error){console.warn('[WARN] Erro ao resetar elemento de áudio:',error);}}try{console.log('[DEBUG] Tentando iniciar reprodução');// Se for iOS, usar nossa função especial para tentar múltiplas estratégias\nif(isIOS){// Para segunda reprodução no iOS, tente desbloquear o áudio novamente\nif(audioContext.current){try{// Desbloquear áudio usando uma nova abordagem para iOS\nif(audioContext.current.state==='suspended'){await audioContext.current.resume();console.log('[DEBUG] AudioContext resumido com sucesso');}// Tocar um som silencioso para desbloquear o áudio\nconst oscillator=audioContext.current.createOscillator();const gainNode=audioContext.current.createGain();gainNode.gain.value=0.01;oscillator.connect(gainNode);gainNode.connect(audioContext.current.destination);oscillator.start(0);oscillator.stop(0.1);// Esperar um momento para que o som seja processado\nawait new Promise(resolve=>setTimeout(resolve,200));console.log('[DEBUG] Áudio desbloqueado novamente');}catch(e){console.warn('[WARN] Falha ao desbloquear áudio novamente:',e);}}// Usar array de URLs para tentativas\nconst urlsToTry=alternativeUrls.current.slice(currentUrlIndex);console.log(\"[DEBUG] Tentando reprodu\\xE7\\xE3o com \".concat(urlsToTry.length,\" URLs\"));// Adicionar mais logs para diagnóstico\nconsole.log('[DEBUG] Estado do áudio antes da reprodução:',{src:audioRef.current.src,paused:audioRef.current.paused,ended:audioRef.current.ended,readyState:audioRef.current.readyState,networkState:audioRef.current.networkState});// Tentativa específica para iOS com uso de promises e retry\nconst maxPlayRetries=3;let playSuccess=false;for(let retry=0;retry<maxPlayRetries&&!playSuccess;retry++){try{console.log(\"[DEBUG] Tentativa de play #\".concat(retry+1,\" no iOS\"));// No iOS, um usuário DEVE ter interagido com a página\n// Verificamos se já houve interação verificando o estado do AudioContext\nif(audioContext.current&&audioContext.current.state==='suspended'){console.log('[DEBUG] Tentando resumir AudioContext antes de reproduzir');await audioContext.current.resume();}// No iOS, force o carregamento antes de tentar reproduzir\nif(audioRef.current.readyState<2){console.log('[DEBUG] Forçando carregamento completo antes de reproduzir');await new Promise(resolve=>{const onCanPlay=()=>{audioRef.current.removeEventListener('canplaythrough',onCanPlay);resolve();};audioRef.current.addEventListener('canplaythrough',onCanPlay);// Se depois de 2 segundos não carregar, continuar mesmo assim\nsetTimeout(resolve,2000);});}// Usar o método play() padrão\nawait audioRef.current.play();console.log('[DEBUG] Reprodução iniciada com sucesso no iOS na tentativa',retry+1);playSuccess=true;}catch(err){console.warn(\"[WARN] Falha na tentativa \".concat(retry+1,\" de reprodu\\xE7\\xE3o:\"),err);if(retry===maxPlayRetries-1){throw err;// Rethrow na última tentativa\n}// Pequena pausa entre tentativas\nawait new Promise(resolve=>setTimeout(resolve,300));// Tentar recarregar o áudio antes da próxima tentativa\ntry{const currentUrl=alternativeUrls.current[currentUrlIndex];const retryUrl=\"\".concat(currentUrl.split('?')[0],\"?retry=\").concat(retry,\"&t=\").concat(new Date().getTime());audioRef.current.src=retryUrl;audioRef.current.load();await new Promise(resolve=>setTimeout(resolve,300));}catch(loadErr){console.warn('[WARN] Erro ao recarregar áudio entre tentativas:',loadErr);}}}// Se chegou aqui, a reprodução foi bem-sucedida\nif(playSuccess){setIsPlaying(true);progressInterval.current=setInterval(()=>{if(audioRef.current){setCurrentTime(audioRef.current.currentTime);}},100);}}else{// Para outros navegadores, usar a abordagem padrão\nawait audioRef.current.play();console.log('[DEBUG] Reprodução iniciada com sucesso');setIsPlaying(true);progressInterval.current=setInterval(()=>{setCurrentTime(audioRef.current.currentTime);},100);}}catch(error){console.error(\"[ERROR] Erro ao iniciar reprodu\\xE7\\xE3o: \".concat(error.name,\" - \").concat(error.message));// Para erros no iOS, tentar recriar o elemento de áudio antes de desistir\nif(isIOS){console.log('[DEBUG] Erro no iOS - tentando recriar o elemento de áudio');try{// Limpar referências antigas\nif(audioRef.current){audioRef.current.pause();audioRef.current.src='';}// Criar um novo elemento de áudio\naudioRef.current=new Audio();audioRef.current.setAttribute('playsinline','true');audioRef.current.setAttribute('webkit-playsinline','true');audioRef.current.setAttribute('controls','true');audioRef.current.preload='auto';// Usar URL com timestamp para evitar cache\nconst currentUrl=alternativeUrls.current[currentUrlIndex];const refreshedUrl=\"\".concat(currentUrl.split('?')[0],\"?t=\").concat(new Date().getTime());audioRef.current.src=refreshedUrl;audioRef.current.load();// Tentar reproduzir uma última vez\nawait audioRef.current.play();// Se chegou aqui, conseguiu reproduzir\nconsole.log('[DEBUG] Reprodução bem-sucedida após recriar elemento');setIsPlaying(true);progressInterval.current=setInterval(()=>{setCurrentTime(audioRef.current.currentTime);},100);return;}catch(finalError){console.error('[ERROR] Falha final ao tentar reproduzir no iOS:',finalError);// Tratamento específico para erros iOS comuns\nif(error.name==='NotAllowedError'){window.alert('O iOS bloqueou a reprodução automática. Toque na tela e tente novamente.');}else if(error.name==='NotSupportedError'){window.alert('Este tipo de áudio não é suportado pelo seu dispositivo iOS. Tente baixar o arquivo.');}else{window.alert('Erro ao reproduzir no iOS. Verifique as configurações de som e tente novamente.');}}}else{window.alert('Não foi possível reproduzir o áudio. Verifique a conexão ou tente novamente mais tarde.');}setIsPlaying(false);setLoadingFailed(true);}};return/*#__PURE__*/React.createElement(Box,{className:classes.audioContainer,style:{alignSelf:isRight?\"flex-end\":\"flex-start\"}},/*#__PURE__*/React.createElement(\"div\",{className:classes.playerControls},/*#__PURE__*/React.createElement(IconButton,{className:classes.playButton,onClick:togglePlayback,disabled:loadingFailed,size:\"small\"},isPlaying?/*#__PURE__*/React.createElement(PauseIcon,{fontSize:\"small\"}):/*#__PURE__*/React.createElement(PlayArrowIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"div\",{className:classes.progressContainer},/*#__PURE__*/React.createElement(LinearProgress,{className:classes.progressBar,variant:\"determinate\",value:audioDuration>0?currentTime/audioDuration*100:0}),/*#__PURE__*/React.createElement(\"div\",{className:classes.timeInfo},/*#__PURE__*/React.createElement(Typography,{className:classes.timeText,variant:\"caption\"},formatTime(currentTime)),/*#__PURE__*/React.createElement(Typography,{className:classes.timeText,variant:\"caption\"},loadingFailed?\"Erro\":!metadataLoaded?\"Carregando...\":formatTime(audioDuration))))));}","map":null,"metadata":{},"sourceType":"module"}