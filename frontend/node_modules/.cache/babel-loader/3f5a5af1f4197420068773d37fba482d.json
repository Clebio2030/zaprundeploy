{"ast":null,"code":"import React,{useState,useRef,useEffect}from\"react\";import{makeStyles}from\"@material-ui/core/styles\";import{IconButton,Typography,LinearProgress,Box}from\"@material-ui/core\";import PlayArrowIcon from\"@material-ui/icons/PlayArrow\";import PauseIcon from\"@material-ui/icons/Pause\";import AudiotrackIcon from\"@material-ui/icons/Audiotrack\";const useStyles=makeStyles(theme=>({audioContainer:{display:\"flex\",flexDirection:\"column\",width:\"100%\",maxWidth:250,backgroundColor:\"transparent\",borderRadius:8,padding:theme.spacing(0.5),border:\"none\",overflow:\"hidden\"},playerControls:{display:\"flex\",alignItems:\"center\",backgroundColor:theme.palette.type===\"dark\"?\"rgba(60, 60, 60, 0.7)\":\"rgba(255, 255, 255, 0.7)\",borderRadius:24,padding:theme.spacing(0.5),boxShadow:\"0px 1px 3px rgba(0, 0, 0, 0.08)\"},playButton:{padding:6,color:theme.palette.primary.main},progressContainer:{display:\"flex\",flexDirection:\"column\",flex:1,marginLeft:theme.spacing(1),marginRight:theme.spacing(1)},progressBar:{height:4,borderRadius:2,marginBottom:4,backgroundColor:\"rgba(0, 0, 0, 0.1)\",\"& .MuiLinearProgress-bar\":{backgroundColor:theme.palette.primary.main}},timeInfo:{display:\"flex\",justifyContent:\"space-between\",alignItems:\"center\"},timeText:{fontSize:10,color:theme.palette.text.secondary,fontWeight:500},audioIcon:{fontSize:20,color:theme.palette.primary.main,marginRight:theme.spacing(1)}}));const formatTime=seconds=>{// Verificar se o valor é válido\nif(seconds===undefined||seconds===null||!isFinite(seconds)||isNaN(seconds)){return\"00:00\";}// Garantir que seja um número positivo\nconst safeSeconds=Math.max(0,Number(seconds));const mins=Math.floor(safeSeconds/60);const secs=Math.floor(safeSeconds%60);return\"\".concat(mins.toString().padStart(2,\"0\"),\":\").concat(secs.toString().padStart(2,\"0\"));};// Verificação melhorada para iOS, incluindo iPads modernos\nconst isIOS=()=>{const userAgent=navigator.userAgent||navigator.vendor||window.opera;// Detecção mais abrangente para iOS\nreturn /iPad|iPhone|iPod/.test(userAgent)&&!window.MSStream||navigator.platform==='MacIntel'&&navigator.maxTouchPoints>1&&!window.MSStream;};// Variável global para uso em todo o arquivo\nconst isIOSDevice=isIOS();console.log('[DEBUG] Dispositivo iOS detectado:',isIOSDevice);// Função aprimorada para lidar com URLs de áudio no iOS\nconst getFullUrl=url=>{if(!url)return\"\";// Verificar se o URL já é um objeto blob\nif(url.startsWith('blob:')){console.log('[DEBUG] URL já é um Blob URL:',url);return url;}// Se a URL já começa com http ou https, retornar como está com timestamp para iOS\nif(url.startsWith('http://')||url.startsWith('https://')){// Para iOS, adicionar parâmetro de timestamp para evitar cache\nif(isIOSDevice){return\"\".concat(url).concat(url.includes('?')?'&':'?',\"t=\").concat(new Date().getTime());}return url;}// Se a URL é relativa, adicionar o endereço do backend\nconst BACKEND_URL=process.env.REACT_APP_BACKEND_URL||window.location.origin;// Se começa com '/', removemos a barra para evitar duplicação\nconst cleanUrl=url.startsWith('/')?url.substring(1):url;// Verificar se já contém o prefixo público antes de adicioná-lo\nconst urlWithPublic=cleanUrl.startsWith('public/')?cleanUrl:\"public/\".concat(cleanUrl);// Construir a URL completa\nlet fullUrl=\"\".concat(BACKEND_URL,\"/\").concat(urlWithPublic);// Para iOS, adicionar parâmetro de timestamp para evitar cache\nif(isIOSDevice){fullUrl=\"\".concat(fullUrl,\"?t=\").concat(new Date().getTime());}console.log('[DEBUG] URL de áudio processada:',{original:url,final:fullUrl});return fullUrl;};// Função especializada para reproduzir áudio no iOS\nconst playAudioInIOS=async(audioElement,url)=>{if(!audioElement||!url){console.error('[ERROR] Elementos inválidos para reprodução no iOS');throw new Error('Elementos inválidos para reprodução');}console.log('[DEBUG] Iniciando reprodução especializada para iOS:',url);// Sempre criar um novo elemento para evitar problemas de cache no iOS\nconst newAudio=new Audio();// Configurar atributos especiais para iOS\nnewAudio.setAttribute('playsinline','true');newAudio.setAttribute('webkit-playsinline','true');newAudio.setAttribute('controls','true');newAudio.crossOrigin='anonymous';newAudio.preload='auto';// Adicionar timestamp para evitar cache\nconst timeStampedUrl=url.includes('?')?\"\".concat(url,\"&t=\").concat(new Date().getTime()):\"\".concat(url,\"?t=\").concat(new Date().getTime());return new Promise((resolve,reject)=>{// Configurar manipuladores de eventos\nnewAudio.oncanplay=async()=>{try{console.log('[DEBUG] Áudio está pronto para reprodução no iOS');// Desbloquear áudio no iOS com contexto de áudio\ntry{const AudioContext=window.AudioContext||window.webkitAudioContext;if(AudioContext){const audioCtx=new AudioContext();const source=audioCtx.createMediaElementSource(newAudio);source.connect(audioCtx.destination);if(audioCtx.state==='suspended'){await audioCtx.resume();}console.log('[DEBUG] Contexto de áudio configurado');}}catch(ctxError){console.warn('[WARN] Erro ao configurar contexto de áudio:',ctxError);// Continuar mesmo com erro\n}// Iniciar reprodução\nawait newAudio.play();console.log('[DEBUG] Reprodução iniciada com sucesso no iOS');// Retornar o novo elemento de áudio para que o chamador possa usá-lo\nresolve(newAudio);}catch(playError){console.error('[ERROR] Erro ao iniciar reprodução no iOS:',playError);reject(playError);}};newAudio.onerror=error=>{console.error('[ERROR] Falha ao carregar áudio no iOS:',newAudio.error?newAudio.error.message:'Erro desconhecido');reject(new Error('Falha ao carregar áudio no iOS'));};// Definir a URL e iniciar carregamento\nnewAudio.src=timeStampedUrl;newAudio.load();// Timeout para caso oncanplay nunca seja disparado\nsetTimeout(()=>{if(newAudio.readyState<3){console.warn('[WARN] Timeout ao aguardar carregamento no iOS');reject(new Error('Timeout ao carregar áudio'));}},5000);});};export default function ChatAudioPlayer(_ref){let{audioUrl,duration,isRight}=_ref;const classes=useStyles();const[isPlaying,setIsPlaying]=useState(false);const[currentTime,setCurrentTime]=useState(0);const[audioDuration,setAudioDuration]=useState(duration||0);const[metadataLoaded,setMetadataLoaded]=useState(false);const[loadingFailed,setLoadingFailed]=useState(false);const[retryCount,setRetryCount]=useState(0);const audioRef=useRef(null);const progressInterval=useRef(null);const alternativeUrls=useRef([]);const audioContext=useRef(null);// Validar duração para garantir valor numérico válido\nconst validateDuration=value=>{// Verificar se o valor é numérico e finito\nif(value===undefined||value===null||!isFinite(value)||isNaN(value)||value<=0){return 0;}return parseFloat(value);};// Atualizar duração quando fornecida como prop\nuseEffect(()=>{const validDuration=validateDuration(duration);if(validDuration>0){console.log(\"[DEBUG] Dura\\xE7\\xE3o v\\xE1lida recebida: \".concat(validDuration,\"s\"));setAudioDuration(validDuration);setMetadataLoaded(true);}else if(audioDuration>0){// Se já temos uma duração válida no estado, considerar os metadados como carregados\nsetMetadataLoaded(true);}},[duration,audioDuration]);// Limpar recursos ao desmontar\nuseEffect(()=>{return()=>{if(progressInterval.current){clearInterval(progressInterval.current);}if(audioRef.current){audioRef.current.pause();}// Limpar o contexto de áudio\nif(audioContext.current){try{audioContext.current.close();}catch(e){console.warn('[WARN] Erro ao fechar contexto de áudio:',e);}}};},[]);// Função melhorada para reprodução de áudio, com tratamento especial para iOS\nconst togglePlayback=async()=>{// Se estiver tocando, apenas pause\nif(isPlaying){console.log('[DEBUG] Pausando reprodução');if(audioRef.current){audioRef.current.pause();clearInterval(progressInterval.current);setIsPlaying(false);}return;}// Reset estado de erro se estiver tentando novamente\nsetLoadingFailed(false);console.log('[DEBUG] Iniciando reprodução com URL:',audioUrl);try{// Estratégia específica para iOS\nif(isIOSDevice){console.log('[DEBUG] Usando estratégia para iOS');// Limpar qualquer reprodução em andamento\nif(audioRef.current){audioRef.current.pause();audioRef.current.currentTime=0;}// Verificar se é uma URL de blob (recém-gravado) ou URL remota\nconst isBlobUrl=audioUrl&&audioUrl.startsWith('blob:');console.log('[DEBUG] É URL de blob?',isBlobUrl);// Processar a URL adequadamente\nconst fullUrl=isBlobUrl?audioUrl:getFullUrl(audioUrl);// Para áudios recém-gravados (blob URL) no iOS, usar estratégia especial\nif(isBlobUrl){console.log('[DEBUG] Reproduzindo áudio recém-gravado no iOS');// Tentar reproduzir com função especializada para iOS\nconst newAudio=await playAudioInIOS(audioRef.current,fullUrl);// Atualizar referência\naudioRef.current=newAudio;// Configurar intervalo para atualizar o progresso\nsetIsPlaying(true);progressInterval.current=setInterval(()=>{if(audioRef.current){setCurrentTime(audioRef.current.currentTime);}},100);// Adicionar listener para quando o áudio terminar\naudioRef.current.onended=()=>{console.log('[DEBUG] Reprodução finalizada');setIsPlaying(false);setCurrentTime(0);clearInterval(progressInterval.current);};return;}// Para URLs remotas no iOS, tentar com várias abordagens\ntry{// Tentar primeiro com função especializada\nconst newAudio=await playAudioInIOS(audioRef.current,fullUrl);// Atualizar referência e configurar\naudioRef.current=newAudio;setIsPlaying(true);// Configurar intervalo para atualizar o progresso\nprogressInterval.current=setInterval(()=>{if(audioRef.current){setCurrentTime(audioRef.current.currentTime);}},100);// Adicionar listener para quando o áudio terminar\naudioRef.current.onended=()=>{console.log('[DEBUG] Reprodução finalizada');setIsPlaying(false);setCurrentTime(0);clearInterval(progressInterval.current);};return;}catch(iosError){console.error('[ERROR] Falha na primeira tentativa para iOS:',iosError);// Se falhar na primeira tentativa e tivermos poucas retentativas, tentar novamente\nif(retryCount<2){console.log('[DEBUG] Tentando novamente após falha no iOS');setRetryCount(prev=>prev+1);// Criar novo elemento de áudio\nconst newAudio=new Audio();audioRef.current=newAudio;// Configurar atributos para iOS\nnewAudio.setAttribute('playsinline','true');newAudio.setAttribute('webkit-playsinline','true');newAudio.preload='auto';newAudio.crossOrigin='anonymous';// Adicionar timestamp para evitar cache\nconst retryUrl=\"\".concat(fullUrl.split('?')[0],\"?retry=\").concat(retryCount,\"&t=\").concat(new Date().getTime());// Tentar carregar e reproduzir\nnewAudio.src=retryUrl;newAudio.load();await newAudio.play();console.log('[DEBUG] Reprodução bem-sucedida após retry no iOS');setIsPlaying(true);progressInterval.current=setInterval(()=>{if(audioRef.current){setCurrentTime(audioRef.current.currentTime);}},100);// Adicionar listener para quando o áudio terminar\nnewAudio.onended=()=>{console.log('[DEBUG] Reprodução finalizada');setIsPlaying(false);setCurrentTime(0);clearInterval(progressInterval.current);};return;}// Se chegou aqui, todas as tentativas falharam\nthrow new Error('Todas as tentativas falharam no iOS');}}else{// Abordagem para navegadores não-iOS\nconsole.log('[DEBUG] Usando abordagem padrão para não-iOS');// Inicializar o elemento de áudio se necessário\nif(!audioRef.current){audioRef.current=new Audio();}// Reset\naudioRef.current.currentTime=0;// URL completa\nconst fullUrl=getFullUrl(audioUrl);// Configurar e carregar\naudioRef.current.src=fullUrl;audioRef.current.load();// Tentar reproduzir\nawait audioRef.current.play();console.log('[DEBUG] Reprodução iniciada com sucesso em navegador não-iOS');// Atualizar estado e configurar monitoramento\nsetIsPlaying(true);progressInterval.current=setInterval(()=>{setCurrentTime(audioRef.current.currentTime);},100);// Adicionar listener para quando o áudio terminar\naudioRef.current.onended=()=>{console.log('[DEBUG] Reprodução finalizada');setIsPlaying(false);setCurrentTime(0);clearInterval(progressInterval.current);};}}catch(error){console.error('[ERROR] Falha ao reproduzir áudio:',error);// Mostrar mensagem de erro mas permitir novas tentativas\nsetIsPlaying(false);setLoadingFailed(true);// Para iOS, sugerir de forma mais clara\nif(isIOSDevice){console.log('[DEBUG] Sugerindo envio do áudio sem reprodução prévia no iOS');}}};return/*#__PURE__*/React.createElement(Box,{className:classes.audioContainer,style:{alignSelf:isRight?\"flex-end\":\"flex-start\"}},/*#__PURE__*/React.createElement(\"div\",{className:classes.playerControls},/*#__PURE__*/React.createElement(IconButton,{className:classes.playButton,onClick:togglePlayback,disabled:false// Nunca desabilitar para permitir novas tentativas\n,size:\"small\"},isPlaying?/*#__PURE__*/React.createElement(PauseIcon,{fontSize:\"small\"}):/*#__PURE__*/React.createElement(PlayArrowIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"div\",{className:classes.progressContainer},/*#__PURE__*/React.createElement(LinearProgress,{className:classes.progressBar,variant:\"determinate\",value:audioDuration>0?currentTime/audioDuration*100:0}),/*#__PURE__*/React.createElement(\"div\",{className:classes.timeInfo},/*#__PURE__*/React.createElement(Typography,{className:classes.timeText,variant:\"caption\"},formatTime(currentTime)),/*#__PURE__*/React.createElement(Typography,{className:classes.timeText,variant:\"caption\"},loadingFailed?\"Toque novamente\":!metadataLoaded?\"Carregando...\":formatTime(audioDuration))))));}","map":null,"metadata":{},"sourceType":"module"}