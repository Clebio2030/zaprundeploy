{"ast":null,"code":"import React,{useState,useRef,useEffect}from'react';import{IconButton,makeStyles,CircularProgress,Paper,Typography,Box,LinearProgress,Tooltip}from'@material-ui/core';import MicIcon from'@material-ui/icons/Mic';import StopIcon from'@material-ui/icons/Stop';import DeleteIcon from'@material-ui/icons/Delete';import SendIcon from'@material-ui/icons/Send';import PauseIcon from'@material-ui/icons/Pause';import PlayArrowIcon from'@material-ui/icons/PlayArrow';const useStyles=makeStyles(theme=>({root:{display:'flex',alignItems:'center'},recordingButton:{color:theme.palette.error.main,animation:'$pulse 1.5s infinite'},'@keyframes pulse':{'0%':{boxShadow:'0 0 0 0 rgba(244, 67, 54, 0.4)'},'70%':{boxShadow:'0 0 0 10px rgba(244, 67, 54, 0)'},'100%':{boxShadow:'0 0 0 0 rgba(244, 67, 54, 0)'}},// Estilo para a barra de gravação estilo WhatsApp\nrecorderBar:{display:'flex',alignItems:'center',backgroundColor:'rgba(30, 30, 30, 0.95)',width:'100%',padding:theme.spacing(0.5,1),borderRadius:24,boxShadow:'0px 2px 4px rgba(0, 0, 0, 0.15)',border:'1px solid rgba(255, 255, 255, 0.1)'},timerText:{color:'#FFFFFF',fontSize:'0.9rem',fontWeight:'bold',marginLeft:theme.spacing(1),marginRight:theme.spacing(1)},waveform:{flex:1,display:'flex',alignItems:'center',justifyContent:'center',height:24,margin:theme.spacing(0,1),backgroundColor:'rgba(255, 255, 255, 0.1)',borderRadius:12,padding:theme.spacing(0.5)},waveformCanvas:{width:'100%',height:'100%'},sendButton:{backgroundColor:'#00A884',color:'white','&:hover':{backgroundColor:'#008F72'},borderRadius:'50%',padding:8,boxShadow:'0px 2px 5px rgba(0, 0, 0, 0.2)',margin:theme.spacing(0,0.5),border:'2px solid rgba(255, 255, 255, 0.3)',transition:'all 0.2s ease-in-out','&:disabled':{backgroundColor:'rgba(0, 168, 132, 0.6)',color:'rgba(255, 255, 255, 0.7)'}},pauseResumeButton:{color:'white',padding:8},trashButton:{color:'white',padding:8},recordingDot:{width:8,height:8,borderRadius:'50%',backgroundColor:'red',marginRight:theme.spacing(1),animation:'$blink 1s infinite'},'@keyframes blink':{'0%':{opacity:1},'50%':{opacity:0.3},'100%':{opacity:1}},reviewContainer:{width:'100%',display:'flex',alignItems:'center',padding:theme.spacing(1.2),backgroundColor:'rgba(255, 255, 255, 0.9)',borderRadius:24,boxShadow:'0 2px 8px rgba(0, 0, 0, 0.08)',border:'none',transition:'all 0.2s ease-in-out','&:hover':{boxShadow:'0 3px 10px rgba(0, 0, 0, 0.12)'}},reviewAudioInfo:{display:'flex',flexDirection:'column',flex:1,marginLeft:theme.spacing(1),marginRight:theme.spacing(1)},progressBar:{width:'100%',height:6,marginTop:6,borderRadius:3,backgroundColor:'rgba(0, 0, 0, 0.05)','& .MuiLinearProgress-bar':{backgroundColor:'#00A884',borderRadius:3}},audioLength:{fontSize:'0.7rem',color:theme.palette.text.secondary,marginTop:2,display:'flex',justifyContent:'space-between'}}));// Função auxiliar para detectar o iOS\nconst isIOSDevice=()=>{const userAgent=navigator.userAgent||navigator.vendor||window.opera;const isIOS=/iPad|iPhone|iPod/.test(userAgent)&&!window.MSStream;console.log(\"[DEBUG] Detectado iOS: \".concat(isIOS,\", UserAgent: \").concat(userAgent));return isIOS;};// Função para converter blob para formato mais compatível com iOS se necessário\nconst convertBlobForIOSIfNeeded=async blob=>{if(!isIOSDevice()||!blob)return Promise.resolve(blob);console.log('[DEBUG] Iniciando conversão de blob para formato compatível com iOS');return new Promise((resolve,reject)=>{try{// Se já for MP3 ou MP4/AAC, apenas retornar\nif(blob.type.includes('mp3')||blob.type.includes('mp4')||blob.type.includes('aac')){console.log('[DEBUG] Blob já está em formato compatível:',blob.type);return resolve(blob);}// Criar elemento de áudio temporário para conversão\nconst audio=new Audio();const blobUrl=URL.createObjectURL(blob);audio.src=blobUrl;// Configurar callbacks\naudio.oncanplay=async()=>{try{console.log('[DEBUG] Áudio carregado, iniciando conversão para WAV');// Criar contexto de áudio para processamento\nconst audioContext=new(window.AudioContext||window.webkitAudioContext)();const audioSource=audioContext.createMediaElementSource(audio);// Configurar nó de destino para gravação\nconst destination=audioContext.createMediaStreamDestination();audioSource.connect(destination);// Reproduzir e gravar em um formato compatível\naudio.play();const chunks=[];const options={mimeType:'audio/wav'};// Tentar usar formatos que o iOS suporta\nconst recorder=new MediaRecorder(destination.stream,options);recorder.ondataavailable=e=>{if(e.data.size>0)chunks.push(e.data);};recorder.onstop=()=>{URL.revokeObjectURL(blobUrl);const newBlob=new Blob(chunks,{type:'audio/wav'});console.log('[DEBUG] Conversão concluída, novo blob:',newBlob.type,newBlob.size,'bytes');resolve(newBlob);};recorder.onerror=err=>{console.error('[ERROR] Erro na conversão:',err);URL.revokeObjectURL(blobUrl);// Se falhar, retornar o blob original\nresolve(blob);};recorder.start();// Parar a gravação quando o áudio terminar\naudio.onended=()=>{recorder.stop();audio.pause();};}catch(error){console.error('[ERROR] Falha ao configurar conversão:',error);URL.revokeObjectURL(blobUrl);// Em caso de erro, retornar o blob original\nresolve(blob);}};audio.onerror=err=>{console.error('[ERROR] Erro ao carregar áudio para conversão:',err);URL.revokeObjectURL(blobUrl);// Em caso de erro, retornar o blob original\nresolve(blob);};// Iniciar carregamento\naudio.load();}catch(error){console.error('[ERROR] Exceção na conversão:',error);// Em caso de exceção, retornar o blob original\nresolve(blob);}});};// Componente de gravação de áudio estilo WhatsApp\nconst ChatAudioRecorder=_ref=>{let{onAudioRecorded,disabled=false}=_ref;const classes=useStyles();const[isRecording,setIsRecording]=useState(false);const[recordingTime,setRecordingTime]=useState(0);const[recordedAudio,setRecordedAudio]=useState(null);const[isPlaying,setIsPlaying]=useState(false);const[isUploading,setIsUploading]=useState(false);const[uploadProgress,setUploadProgress]=useState(0);const[isPaused,setIsPaused]=useState(false);const[currentTime,setCurrentTime]=useState(0);const[audioDuration,setAudioDuration]=useState(0);const[isLoadingAudio,setIsLoadingAudio]=useState(false);const[audioError,setAudioError]=useState(null);// Refs\nconst mediaRecorderRef=useRef(null);const audioChunksRef=useRef([]);const audioStreamRef=useRef(null);const timerRef=useRef(null);const canvasRef=useRef(null);const audioContextRef=useRef(null);const analyserRef=useRef(null);const animationRef=useRef(null);const audioRef=useRef(null);const progressIntervalRef=useRef(null);const audioPlayTriesRef=useRef(0);// Formatação de tempo (mm:ss)\nconst formatTime=seconds=>{// Verificar se o valor é válido\nif(seconds===undefined||seconds===null||isNaN(seconds)||!isFinite(seconds)){return\"00:00\";}// Garantir que é um número e limitar a valores razoáveis\nconst safeSeconds=Math.min(Math.max(0,Number(seconds)),3600);// Limitar a 1 hora\nconst mins=Math.floor(safeSeconds/60);const secs=Math.floor(safeSeconds%60);return\"\".concat(mins.toString().padStart(2,'0'),\":\").concat(secs.toString().padStart(2,'0'));};// Função para iniciar o visualizador de áudio\nconst startVisualizer=()=>{if(!canvasRef.current||!analyserRef.current)return;const canvas=canvasRef.current;const canvasCtx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;analyserRef.current.fftSize=256;const bufferLength=analyserRef.current.frequencyBinCount;const dataArray=new Uint8Array(bufferLength);const draw=()=>{if(!isRecording||isPaused)return;animationRef.current=requestAnimationFrame(draw);analyserRef.current.getByteFrequencyData(dataArray);canvasCtx.clearRect(0,0,width,height);// Desenhar forma de onda estilo WhatsApp\nconst barWidth=2;const gap=1;const barCount=Math.floor(width/(barWidth+gap));const step=Math.floor(bufferLength/barCount)||1;for(let i=0;i<barCount;i++){const dataIndex=i*step;if(dataIndex>=bufferLength)break;// Usar a média de alguns valores para suavizar\nlet sum=0;let count=0;for(let j=0;j<step&&dataIndex+j<bufferLength;j++){sum+=dataArray[dataIndex+j];count++;}const average=count>0?sum/count:0;const barHeight=Math.max(1,average/255*height);const x=i*(barWidth+gap);const y=(height-barHeight)/2;// Cor cinza claro para as barras de visualização\ncanvasCtx.fillStyle='#CCCCCC';canvasCtx.fillRect(x,y,barWidth,barHeight);}};draw();};// Função para tentar reproduzir áudio usando diferentes métodos\nconst attemptPlayAudio=async(audioElement,url,mimeType)=>{try{console.log(\"[DEBUG] Tentativa de reprodu\\xE7\\xE3o #\".concat(audioPlayTriesRef.current+1,\" - URL: \").concat(url.substring(0,50),\"...\"));// Verificar se é iOS\nconst isIOS=isIOSDevice();// Para iOS, tentar abordagens específicas\nif(isIOS&&audioPlayTriesRef.current===0){console.log('[DEBUG] Estratégia para iOS: usando atributos específicos');// Configurar atributos auxiliares para iOS\naudioElement.setAttribute('playsinline','true');audioElement.setAttribute('webkit-playsinline','true');audioElement.setAttribute('controls','true');}// Limpar eventos anteriores\naudioElement.oncanplay=null;audioElement.oncanplaythrough=null;// Registrar eventos de diagnóstico\naudioElement.oncanplay=()=>{console.log('[DEBUG] Evento canplay disparado');};audioElement.oncanplaythrough=()=>{console.log('[DEBUG] Evento canplaythrough disparado');};// Tentar reproduzir\nawait audioElement.play();console.log('[DEBUG] Reprodução iniciada com sucesso');audioPlayTriesRef.current=0;// Resetar contador após sucesso\nreturn true;}catch(error){audioPlayTriesRef.current++;console.error(\"[ERROR] Tentativa #\".concat(audioPlayTriesRef.current,\" falhou:\"),error.message);// Verificar se devemos tentar outra abordagem\nif(audioPlayTriesRef.current<3){// Se falhou no iOS, tentar abordagem alternativa no próximo retry\nif(isIOSDevice()){console.log('[DEBUG] Tentando método alternativo para iOS');// Tentar criar um novo elemento de áudio\nif(audioPlayTriesRef.current===1){const tempAudio=new Audio();audioRef.current=tempAudio;// Configurar novo elemento de áudio\ntempAudio.src=url;tempAudio.preload=\"auto\";tempAudio.crossOrigin=\"anonymous\";// Tentar reproduzir com este novo elemento\nreturn await attemptPlayAudio(tempAudio,url,mimeType);}// Na última tentativa, tentar usar um formato diferente\nif(audioPlayTriesRef.current===2){if(recordedAudio&&recordedAudio.blob){try{// Converter para formato mais compatível com iOS\nconst convertedBlob=await convertBlobForIOSIfNeeded(recordedAudio.blob);const newUrl=URL.createObjectURL(convertedBlob);// Configurar elemento com a nova URL\naudioElement.src=newUrl;audioElement.load();return await attemptPlayAudio(audioElement,newUrl,convertedBlob.type);}catch(convError){console.error('[ERROR] Falha na conversão:',convError);}}}}return false;}else{// Registrar o erro após todas as tentativas\nsetAudioError(error.message);return false;}}};// Função para reproduzir o áudio gravado\nconst playRecordedAudio=async()=>{if(!audioRef.current||!recordedAudio||isLoadingAudio)return;// Evitar operações simultâneas\nif(isLoadingAudio){console.log('[DEBUG] Operação de áudio em andamento, ignorando');return;}if(isPlaying){audioRef.current.pause();clearInterval(progressIntervalRef.current);setIsPlaying(false);return;}// Resetar contador de tentativas\naudioPlayTriesRef.current=0;setAudioError(null);setIsLoadingAudio(true);try{// Verificar se a URL do áudio ainda é válida\nif(recordedAudio.url){console.log('[DEBUG] Tentando reproduzir áudio gravado:',recordedAudio.url.substring(0,50)+'...');console.log('[DEBUG] Tipo MIME:',recordedAudio.mimeType||'desconhecido');// Adicionar tratamento de erros\naudioRef.current.onerror=e=>{console.error('[ERROR] Falha ao reproduzir áudio:',e);setIsPlaying(false);setIsLoadingAudio(false);// Mensagem mais informativa para iOS\nif(isIOSDevice()){setAudioError(\"Falha ao reproduzir (iOS): \".concat(audioRef.current.error&&audioRef.current.error.message||'Erro desconhecido'));}else{setAudioError(\"Erro: \".concat(audioRef.current.error&&audioRef.current.error.message||'Erro desconhecido'));}};// Adicionar mais diagnósticos\naudioRef.current.onloadstart=()=>{console.log('[DEBUG] Carregamento de áudio iniciado');};audioRef.current.onloadeddata=()=>{console.log('[DEBUG] Dados de áudio carregados');};// Adicionar atributos específicos para iOS\nif(isIOSDevice()){console.log('[DEBUG] Adicionando atributos específicos para iOS');audioRef.current.setAttribute('playsinline','true');audioRef.current.setAttribute('webkit-playsinline','true');audioRef.current.setAttribute('controls','true');audioRef.current.setAttribute('crossorigin','anonymous');audioRef.current.muted=false;}// Registrar eventos adicionais para diagnóstico\naudioRef.current.oncanplay=()=>{console.log('[DEBUG] Evento canplay disparado');};audioRef.current.oncanplaythrough=()=>{console.log('[DEBUG] Evento canplaythrough disparado');};// Resetar para o início\naudioRef.current.currentTime=0;// Pequena pausa para garantir que tudo esteja pronto\nawait new Promise(resolve=>setTimeout(resolve,100));try{// Tentar reproduzir o áudio\nawait audioRef.current.play();console.log('[DEBUG] Reprodução iniciada com sucesso');// Configurar intervalo para atualizar a posição atual\nprogressIntervalRef.current=setInterval(()=>{if(audioRef.current){setCurrentTime(audioRef.current.currentTime);}},100);setIsPlaying(true);}catch(error){console.error(\"[ERROR] Erro ao iniciar reprodu\\xE7\\xE3o: \".concat(error.name,\" - \").concat(error.message));// Tratamento específico para o erro AbortError\nif(error.name==='AbortError'){console.log('[DEBUG] Detectado AbortError, tentando novamente após pequena pausa');// Pausa para permitir que operações pendentes terminem\nawait new Promise(resolve=>setTimeout(resolve,500));try{// Tentar novamente uma vez mais\nawait audioRef.current.play();console.log('[DEBUG] Reprodução iniciada com sucesso após retry');// Configurar intervalo para atualizar a posição atual\nprogressIntervalRef.current=setInterval(()=>{if(audioRef.current){setCurrentTime(audioRef.current.currentTime);}},100);setIsPlaying(true);}catch(retryError){console.error(\"[ERROR] Falha na segunda tentativa: \".concat(retryError.name,\" - \").concat(retryError.message));// Estratégias adicionais específicas para iOS\nif(isIOSDevice()&&audioPlayTriesRef.current<2){audioPlayTriesRef.current++;console.log(\"[DEBUG] Tentando m\\xE9todo alternativo #\".concat(audioPlayTriesRef.current,\" para iOS\"));try{if(audioPlayTriesRef.current===1){// Criar um novo elemento de áudio\nconsole.log('[DEBUG] Estratégia 1: Criando novo elemento de áudio');const tempAudio=new Audio();audioRef.current=tempAudio;tempAudio.src=recordedAudio.url;tempAudio.preload=\"auto\";tempAudio.crossOrigin=\"anonymous\";tempAudio.setAttribute('playsinline','true');tempAudio.setAttribute('webkit-playsinline','true');tempAudio.setAttribute('controls','true');// Esperar um pouco para carregar\nawait new Promise(resolve=>setTimeout(resolve,300));await tempAudio.play();console.log('[DEBUG] Reprodução iniciada com sucesso com elemento alternativo');// Configurar intervalo para atualizar a posição atual\nprogressIntervalRef.current=setInterval(()=>{if(tempAudio){setCurrentTime(tempAudio.currentTime);}},100);setIsPlaying(true);}else if(audioPlayTriesRef.current===2&&recordedAudio.blob){// Tentar usar formato diferente\nconsole.log('[DEBUG] Estratégia 2: Convertendo para formato compatível com iOS');const convertedBlob=await convertBlobForIOSIfNeeded(recordedAudio.blob);const newUrl=URL.createObjectURL(convertedBlob);audioRef.current.src=newUrl;audioRef.current.load();// Esperar carregar o novo formato\nawait new Promise(resolve=>setTimeout(resolve,300));await audioRef.current.play();console.log('[DEBUG] Reprodução iniciada com sucesso após conversão');// Configurar intervalo para atualizar a posição atual\nprogressIntervalRef.current=setInterval(()=>{if(audioRef.current){setCurrentTime(audioRef.current.currentTime);}},100);setIsPlaying(true);}}catch(specialError){console.error(\"[ERROR] Falha na estrat\\xE9gia especial para iOS: \".concat(specialError.message));handlePlayError(specialError);}}else{handlePlayError(retryError);}}}else{handlePlayError(error);}}}else{setAudioError('URL de áudio inválida');}}catch(error){console.error('[ERROR] Exceção ao tentar reproduzir áudio:',error);handlePlayError(error);}finally{setIsLoadingAudio(false);}};// Função auxiliar para tratar erros de reprodução\nconst handlePlayError=error=>{console.error('[ERROR] Tratando erro de reprodução:',error);setIsPlaying(false);// Mensagens mais amigáveis com base no tipo de erro\nif(error.name==='NotAllowedError'){setAudioError('Reprodução bloqueada pelo navegador. Toque na tela e tente novamente.');}else if(error.name==='NotSupportedError'){setAudioError('Formato de áudio não suportado pelo seu dispositivo.');}else{setAudioError(\"Erro ao reproduzir: \".concat(error.message||'Desconhecido'));}};// Função para enviar o áudio gravado\nconst sendRecordedAudio=async()=>{if(!recordedAudio||!recordedAudio.blob){console.error('[ERROR] Nenhum áudio disponível para envio');return;}if(recordedAudio.blob.size===0){console.error('[ERROR] Blob de áudio vazio');window.alert('O arquivo de áudio está vazio. Tente gravar novamente.');return;}try{// Verificar se estamos em um dispositivo iOS\nconst isIOS=isIOSDevice();// Determinar a extensão com base no tipo MIME\nlet extension='webm';let mimeType=recordedAudio.mimeType||recordedAudio.blob.type;console.log('[DEBUG] MIME type original para envio:',mimeType);// Para iOS, preferir formatos mais compatíveis\nif(isIOS){console.log('[DEBUG] Preparando formato otimizado para iOS');// Tentar converter o blob para um formato mais compatível com iOS\nconst iosCompatibleBlob=await convertBlobForIOSIfNeeded(recordedAudio.blob);// Se o blob foi convertido, usar o novo tipo\nif(iosCompatibleBlob!==recordedAudio.blob){mimeType=iosCompatibleBlob.type;console.log('[DEBUG] Blob convertido para:',mimeType);}// iOS tem melhor compatibilidade com MP4/AAC ou MP3\nif(mimeType.includes('mp4')||mimeType.includes('aac')){extension='mp4';}else if(mimeType.includes('mp3')||mimeType.includes('mpeg')){extension='mp3';}else if(mimeType.includes('wav')){extension='wav';}else{// Fallback para tipo genérico no iOS\nmimeType='audio/mp4';extension='mp4';}}else{// Mapear o tipo MIME para a extensão correta\nif(mimeType.includes('mp3')||mimeType.includes('mpeg')){extension='mp3';}else if(mimeType.includes('ogg')){extension='ogg';}else if(mimeType.includes('wav')){extension='wav';}else if(mimeType.includes('mp4')){extension='mp4';}else if(mimeType.includes('webm')){extension='webm';}}console.log('[DEBUG] Extensão determinada:',extension);console.log('[DEBUG] MIME type final:',mimeType);// Usar o blob original ou o convertido\nconst finalBlob=isIOS?await convertBlobForIOSIfNeeded(recordedAudio.blob):recordedAudio.blob;// Criar arquivo para envio com o nome usando timestamp para evitar conflitos\nconst fileName=\"audio_\".concat(Date.now(),\".\").concat(extension);const audioFile=new File([finalBlob],fileName,{type:mimeType});console.log(\"[DEBUG] Arquivo de \\xE1udio criado: \".concat(audioFile.name,\", tipo: \").concat(audioFile.type,\", \").concat(audioFile.size,\" bytes\"));// Limpar erro se existente\nsetAudioError(null);// Iniciar upload\nsetIsUploading(true);// Callback para o componente pai\nonAudioRecorded(audioFile,progress=>{setUploadProgress(progress);},()=>{setIsUploading(false);// Limpar gravação após envio\nif(recordedAudio&&recordedAudio.url){URL.revokeObjectURL(recordedAudio.url);}setRecordedAudio(null);setRecordingTime(0);setCurrentTime(0);});}catch(error){console.error('[ERROR] Falha ao processar arquivo de áudio:',error);window.alert('Erro ao processar o áudio. Tente novamente.');setIsUploading(false);}};// Função para iniciar gravação\nconst startRecording=async()=>{console.log('[DEBUG] Iniciando gravação');try{// Revogar URL de qualquer gravação anterior\nif(recordedAudio&&recordedAudio.url){URL.revokeObjectURL(recordedAudio.url);setRecordedAudio(null);}// Limpar erro se existente\nsetAudioError(null);// Verificar se estamos em um dispositivo iOS\nconst isIOS=isIOSDevice();// Solicitar permissão para o microfone com configurações otimizadas\nconst stream=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true,autoGainControl:true}});console.log('[DEBUG] Permissão de microfone concedida');audioStreamRef.current=stream;// Configurar o contexto de áudio para visualização\nconst audioContext=new(window.AudioContext||window.webkitAudioContext)();audioContextRef.current=audioContext;const analyser=audioContext.createAnalyser();analyserRef.current=analyser;const source=audioContext.createMediaStreamSource(stream);source.connect(analyser);// Redefinir o array de chunks\naudioChunksRef.current=[];// Testar formatos suportados - em ordem de preferência\n// Para iOS, priorizar formatos compatíveis\nconst tryFormats=isIOS?['audio/mp4','audio/mp4;codecs=mp4a','audio/aac','audio/mpeg','audio/mp3','audio/wav','audio/ogg;codecs=opus','audio/webm;codecs=opus','audio/webm','audio/ogg']:['audio/webm;codecs=opus','audio/mp4;codecs=mp4a','audio/ogg;codecs=opus','audio/webm','audio/ogg','audio/mp3','audio/mpeg'];// Detectar formatos disponíveis e suportados\nlet supportedFormats=[];for(const format of tryFormats){if(MediaRecorder.isTypeSupported(format)){supportedFormats.push(format);console.log(\"[DEBUG] Formato suportado: \".concat(format));}}console.log(\"[DEBUG] Total de formatos suportados: \".concat(supportedFormats.length));let selectedMimeType='';// Escolher o formato mais adequado\nif(supportedFormats.length>0){// Para iOS, preferir MP4 ou AAC\nif(isIOS){const iosFormats=supportedFormats.filter(f=>f.includes('mp4')||f.includes('aac')||f.includes('mp3')||f.includes('mpeg'));if(iosFormats.length>0){selectedMimeType=iosFormats[0];}else{selectedMimeType=supportedFormats[0];}}else{// Para outros dispositivos, usar o primeiro formato suportado\nselectedMimeType=supportedFormats[0];}}else{console.warn('[WARN] Nenhum formato específico é suportado. Usando padrão do navegador.');selectedMimeType='';}console.log(\"[DEBUG] Usando formato de grava\\xE7\\xE3o: \".concat(selectedMimeType||'padrão do navegador'));// Configurações adicionais para iOS\nconst recorderOptions={mimeType:selectedMimeType};// Adicionar configuração de bitrate apenas para formatos que suportam\nif(!isIOS||!selectedMimeType.includes('mp4')){recorderOptions.audioBitsPerSecond=128000;// 128kbps\n}console.log('[DEBUG] Opções do recorder:',JSON.stringify(recorderOptions));// Criar MediaRecorder com configurações otimizadas\nconst recorder=new MediaRecorder(stream,recorderOptions);mediaRecorderRef.current=recorder;// Configurar eventos para o MediaRecorder\nrecorder.addEventListener('dataavailable',event=>{if(event.data.size>0){console.log(\"[DEBUG] Chunk de dados recebido: \".concat(event.data.size,\" bytes\"));audioChunksRef.current.push(event.data);}});recorder.addEventListener('start',()=>{console.log('[DEBUG] Gravação iniciada');setIsRecording(true);setIsPaused(false);// Iniciar timer\ntimerRef.current=setInterval(()=>{setRecordingTime(prev=>prev+1);},1000);// Iniciar visualizador\nif(canvasRef.current){startVisualizer();}});recorder.addEventListener('stop',handleRecordingStopped);recorder.addEventListener('error',event=>{console.error('[ERROR] Erro no MediaRecorder:',event);window.alert('Erro na gravação. Verifique o microfone.');setIsRecording(false);});// Iniciar gravação\nrecorder.start(1000);// Captura chunks a cada 1 segundo\n}catch(error){console.error('[ERROR] Erro ao iniciar gravação:',error);window.alert('Erro ao acessar o microfone. Verifique as permissões do navegador.');}};// Manipulador de interrupção da gravação\nconst handleRecordingStopped=async()=>{console.log('[DEBUG] Gravação parada. Total de chunks:',audioChunksRef.current.length);// Parar o stream de áudio\nif(audioStreamRef.current){audioStreamRef.current.getTracks().forEach(track=>track.stop());}// Verificar se capturamos algum dado\nif(!audioChunksRef.current||audioChunksRef.current.length===0){console.error('[ERROR] Nenhum dado de áudio capturado');window.alert('Não foi possível capturar áudio. Verifique o microfone.');return;}// Obter o tipo MIME usado na gravação\nconst mimeType=mediaRecorderRef.current?mediaRecorderRef.current.mimeType:'audio/webm';console.log('[DEBUG] MimeType usado na gravação:',mimeType);// Criar o blob de áudio com o tipo MIME correto\nconst audioBlob=new Blob(audioChunksRef.current,{type:mimeType});console.log(\"[DEBUG] Blob de \\xE1udio criado: \".concat(audioBlob.size,\" bytes, tipo: \").concat(audioBlob.type));if(audioBlob.size===0){console.error('[ERROR] Blob de áudio vazio');window.alert('Erro na gravação. Tente novamente.');return;}// Para iOS, tentar otimizar o formato\nlet finalBlob=audioBlob;if(isIOSDevice()){console.log('[DEBUG] Otimizando formato para iOS');try{finalBlob=await convertBlobForIOSIfNeeded(audioBlob);}catch(error){console.error('[ERROR] Falha ao otimizar para iOS:',error);// Continuar com o blob original\n}}// Guardar a duração da gravação (verificar se é válida)\nconst finalDuration=recordingTime>0?recordingTime:0;console.log(\"[DEBUG] Dura\\xE7\\xE3o da grava\\xE7\\xE3o: \".concat(finalDuration,\" segundos\"));// Criar URL do blob para reprodução\nconst audioUrl=URL.createObjectURL(finalBlob);// Salvar áudio gravado imediatamente com a duração da gravação\nsetAudioDuration(finalDuration);setRecordedAudio({blob:finalBlob,url:audioUrl,duration:finalDuration,mimeType:finalBlob.type});// Inicializar o elemento de áudio para reprodução\nif(!audioRef.current){audioRef.current=new Audio();}// Configurar atributos adicionais para iOS\nif(isIOSDevice()){audioRef.current.setAttribute('playsinline','true');audioRef.current.setAttribute('webkit-playsinline','true');audioRef.current.setAttribute('controls','true');audioRef.current.muted=false;}audioRef.current.src=audioUrl;audioRef.current.preload=\"auto\";audioRef.current.load();// Tentar obter a duração exata do áudio\ntry{const tempAudio=new Audio();tempAudio.preload=\"metadata\";// Configurar atributos para iOS também no elemento temporário\nif(isIOSDevice()){tempAudio.setAttribute('playsinline','true');tempAudio.setAttribute('webkit-playsinline','true');}tempAudio.src=audioUrl;tempAudio.addEventListener('loadedmetadata',()=>{const actualDuration=tempAudio.duration;console.log(\"[DEBUG] Dura\\xE7\\xE3o real do \\xE1udio: \".concat(actualDuration,\" segundos\"));// Verificar se a duração é válida antes de usar\nif(!isNaN(actualDuration)&&isFinite(actualDuration)&&actualDuration>0){setAudioDuration(actualDuration);// Atualizar objeto de áudio com a duração correta\nsetRecordedAudio(prev=>({...prev,duration:actualDuration}));}});// Adicionar tratamento de erro\ntempAudio.addEventListener('error',error=>{console.error('[ERROR] Erro ao carregar metadados do áudio:',error);});// Iniciar carregamento\ntempAudio.load();}catch(error){console.warn('[WARN] Erro ao tentar obter duração do áudio:',error);// Continuar usando a duração da gravação\n}};// Função para pausar/continuar a gravação\nconst togglePauseRecording=()=>{if(!mediaRecorderRef.current)return;if(isPaused){// Continuar gravação\nif(mediaRecorderRef.current.state==='paused'){mediaRecorderRef.current.resume();}// Reiniciar timer\ntimerRef.current=setInterval(()=>{setRecordingTime(prevTime=>prevTime+1);},1000);// Reiniciar visualizador\nstartVisualizer();setIsPaused(false);}else{// Pausar gravação\nif(mediaRecorderRef.current.state==='recording'){mediaRecorderRef.current.pause();}// Pausar timer\nif(timerRef.current){clearInterval(timerRef.current);}// Pausar visualizador\nif(animationRef.current){cancelAnimationFrame(animationRef.current);}setIsPaused(true);}};// Função para parar a gravação\nconst stopRecording=()=>{if(mediaRecorderRef.current&&mediaRecorderRef.current.state!=='inactive'){console.log('[DEBUG] Parando gravação');mediaRecorderRef.current.stop();// Limpar timer\nif(timerRef.current){clearInterval(timerRef.current);timerRef.current=null;}// Parar visualizador\nif(animationRef.current){cancelAnimationFrame(animationRef.current);animationRef.current=null;}setIsRecording(false);setIsPaused(false);}};// Função para cancelar a gravação\nconst cancelRecording=()=>{console.log('[DEBUG] Cancelando gravação');// Parar a gravação se estiver ativa\nif(mediaRecorderRef.current&&mediaRecorderRef.current.state!=='inactive'){mediaRecorderRef.current.stop();// Parar o stream de áudio\nif(audioStreamRef.current){audioStreamRef.current.getTracks().forEach(track=>track.stop());}}// Limpar timer\nif(timerRef.current){clearInterval(timerRef.current);timerRef.current=null;}// Parar visualizador\nif(animationRef.current){cancelAnimationFrame(animationRef.current);animationRef.current=null;}// Resetar estado\nsetIsRecording(false);setIsPaused(false);setRecordingTime(0);// Limpar gravação se existir\nif(recordedAudio&&recordedAudio.url){URL.revokeObjectURL(recordedAudio.url);setRecordedAudio(null);}};// Eventos de áudio\nuseEffect(()=>{if(audioRef.current&&recordedAudio){// Carregar metadados do áudio quando disponível\naudioRef.current.onloadedmetadata=()=>{const audioElementDuration=audioRef.current.duration;if(!isNaN(audioElementDuration)&&isFinite(audioElementDuration)&&audioElementDuration>0){console.log(\"[DEBUG] Dura\\xE7\\xE3o do \\xE1udio carregada: \".concat(audioElementDuration,\"s\"));setAudioDuration(audioElementDuration);// Atualizar objeto de áudio com a duração correta\nsetRecordedAudio(prev=>({...prev,duration:audioElementDuration}));}else{console.warn('[WARN] Duração inválida do elemento de áudio:',audioElementDuration);}};audioRef.current.onended=()=>{setIsPlaying(false);setCurrentTime(0);clearInterval(progressIntervalRef.current);};}return()=>{if(progressIntervalRef.current){clearInterval(progressIntervalRef.current);}};},[recordedAudio]);// Ajustar o canvas quando necessário\nuseEffect(()=>{if(isRecording&&canvasRef.current){setTimeout(()=>{canvasRef.current.width=canvasRef.current.offsetWidth;canvasRef.current.height=canvasRef.current.offsetHeight;if(!isPaused)startVisualizer();},100);}},[isRecording,isPaused]);// Limpar recursos quando o componente for desmontado\nuseEffect(()=>{return()=>{cancelRecording();if(recordedAudio&&recordedAudio.url){URL.revokeObjectURL(recordedAudio.url);}if(progressIntervalRef.current){clearInterval(progressIntervalRef.current);}};},[]);// Renderizar a barra de gravação estilo WhatsApp\nif(isRecording){return/*#__PURE__*/React.createElement(\"div\",{className:classes.recorderBar},/*#__PURE__*/React.createElement(IconButton,{className:classes.trashButton,onClick:cancelRecording},/*#__PURE__*/React.createElement(DeleteIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"div\",{className:classes.recordingDot}),/*#__PURE__*/React.createElement(Typography,{className:classes.timerText},formatTime(recordingTime)),/*#__PURE__*/React.createElement(\"div\",{className:classes.waveform},/*#__PURE__*/React.createElement(\"canvas\",{ref:canvasRef,className:classes.waveformCanvas})),/*#__PURE__*/React.createElement(IconButton,{className:classes.pauseResumeButton,onClick:togglePauseRecording},isPaused?/*#__PURE__*/React.createElement(PlayArrowIcon,{fontSize:\"small\"}):/*#__PURE__*/React.createElement(PauseIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(IconButton,{className:classes.sendButton,onClick:stopRecording,disabled:recordingTime<1},/*#__PURE__*/React.createElement(SendIcon,{fontSize:\"small\"})));}// Renderizar o player de revisão se um áudio foi gravado\nif(recordedAudio){// Garantir que a duração seja sempre um número válido\nconst displayDuration=!isNaN(audioDuration)&&isFinite(audioDuration)&&audioDuration>0?audioDuration:!isNaN(recordedAudio.duration)&&isFinite(recordedAudio.duration)&&recordedAudio.duration>0?recordedAudio.duration:0;// Calcular a porcentagem de progresso de forma segura\nconst progressPercentage=isPlaying&&displayDuration>0?Math.min(100,Math.max(0,currentTime/displayDuration*100)):0;return/*#__PURE__*/React.createElement(\"div\",{className:classes.reviewContainer},/*#__PURE__*/React.createElement(IconButton,{onClick:cancelRecording,size:\"small\"},/*#__PURE__*/React.createElement(DeleteIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"div\",{className:classes.reviewAudioInfo},/*#__PURE__*/React.createElement(\"div\",{style:{display:'flex',alignItems:'center'}},/*#__PURE__*/React.createElement(IconButton,{onClick:playRecordedAudio,size:\"small\",disabled:isLoadingAudio},isLoadingAudio?/*#__PURE__*/React.createElement(CircularProgress,{size:20,color:\"inherit\"}):isPlaying?/*#__PURE__*/React.createElement(PauseIcon,{fontSize:\"small\"}):/*#__PURE__*/React.createElement(PlayArrowIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(Typography,{variant:\"caption\"},\"\\xC1udio gravado \",isIOSDevice()?\" (iOS)\":\"\",audioError&&/*#__PURE__*/React.createElement(Typography,{variant:\"caption\",style:{color:'red',display:'block',fontSize:'0.7rem'}},audioError))),/*#__PURE__*/React.createElement(LinearProgress,{className:classes.progressBar,variant:\"determinate\",value:progressPercentage}),/*#__PURE__*/React.createElement(\"div\",{className:classes.audioLength},/*#__PURE__*/React.createElement(\"span\",null,formatTime(isPlaying?currentTime:0)),/*#__PURE__*/React.createElement(\"span\",null,formatTime(displayDuration)))),/*#__PURE__*/React.createElement(IconButton,{className:classes.sendButton,onClick:sendRecordedAudio,disabled:isUploading,size:\"small\"},isUploading?/*#__PURE__*/React.createElement(CircularProgress,{size:20,color:\"inherit\"}):/*#__PURE__*/React.createElement(SendIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"audio\",{ref:audioRef,src:recordedAudio.url,style:{display:'none'},preload:\"metadata\",playsInline:true,\"webkit-playsinline\":\"true\"}));}// Renderizar apenas o botão de microfone\nreturn/*#__PURE__*/React.createElement(Tooltip,{title:\"Gravar \\xE1udio\"},/*#__PURE__*/React.createElement(\"span\",{className:classes.root},/*#__PURE__*/React.createElement(IconButton,{color:\"primary\",\"aria-label\":\"gravar \\xE1udio\",onClick:startRecording,disabled:disabled||isUploading},/*#__PURE__*/React.createElement(MicIcon,null))));};export default ChatAudioRecorder;","map":null,"metadata":{},"sourceType":"module"}