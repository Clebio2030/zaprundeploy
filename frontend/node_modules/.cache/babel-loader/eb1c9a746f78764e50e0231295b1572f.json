{"ast":null,"code":"import React,{useState,useRef,useEffect}from\"react\";import{makeStyles}from\"@material-ui/core/styles\";import{IconButton,Typography,LinearProgress,Box}from\"@material-ui/core\";import PlayArrowIcon from\"@material-ui/icons/PlayArrow\";import PauseIcon from\"@material-ui/icons/Pause\";import AudiotrackIcon from\"@material-ui/icons/Audiotrack\";const useStyles=makeStyles(theme=>({audioContainer:{display:\"flex\",flexDirection:\"column\",width:\"100%\",maxWidth:250,backgroundColor:\"transparent\",borderRadius:8,padding:theme.spacing(0.5),border:\"none\",overflow:\"hidden\"},playerControls:{display:\"flex\",alignItems:\"center\",backgroundColor:theme.palette.type===\"dark\"?\"rgba(60, 60, 60, 0.7)\":\"rgba(255, 255, 255, 0.7)\",borderRadius:24,padding:theme.spacing(0.5),boxShadow:\"0px 1px 3px rgba(0, 0, 0, 0.08)\"},playButton:{padding:6,color:theme.palette.primary.main},progressContainer:{display:\"flex\",flexDirection:\"column\",flex:1,marginLeft:theme.spacing(1),marginRight:theme.spacing(1)},progressBar:{height:4,borderRadius:2,marginBottom:4,backgroundColor:\"rgba(0, 0, 0, 0.1)\",\"& .MuiLinearProgress-bar\":{backgroundColor:theme.palette.primary.main}},timeInfo:{display:\"flex\",justifyContent:\"space-between\",alignItems:\"center\"},timeText:{fontSize:10,color:theme.palette.text.secondary,fontWeight:500},audioIcon:{fontSize:20,color:theme.palette.primary.main,marginRight:theme.spacing(1)}}));const formatTime=seconds=>{// Verificar se o valor é válido\nif(seconds===undefined||seconds===null||!isFinite(seconds)||isNaN(seconds)){return\"00:00\";}// Garantir que seja um número positivo\nconst safeSeconds=Math.max(0,Number(seconds));const mins=Math.floor(safeSeconds/60);const secs=Math.floor(safeSeconds%60);return\"\".concat(mins.toString().padStart(2,\"0\"),\":\").concat(secs.toString().padStart(2,\"0\"));};// Verificação melhorada para iOS, incluindo iPads modernos\nconst isIOS=()=>{const userAgent=navigator.userAgent||navigator.vendor||window.opera;// Detecção mais abrangente para iOS\nreturn /iPad|iPhone|iPod/.test(userAgent)&&!window.MSStream||navigator.platform==='MacIntel'&&navigator.maxTouchPoints>1&&!window.MSStream;};// Variável global para uso em todo o arquivo\nconst isIOSDevice=isIOS();console.log('[DEBUG] Dispositivo iOS detectado:',isIOSDevice);// Função para carregar e desbloquear áudio no iOS\nconst unlockAudioOnIOS=async()=>{if(!isIOSDevice)return Promise.resolve();console.log('[DEBUG] Tentando desbloquear áudio no iOS');try{// Criar um contexto de áudio temporário\nconst AudioContext=window.AudioContext||window.webkitAudioContext;if(!AudioContext)return Promise.resolve();const audioCtx=new AudioContext();// Verificar se o contexto está em estado suspenso\nif(audioCtx.state==='suspended'){await audioCtx.resume();}// Criar um oscilador silencioso e tocar por um instante\nconst oscillator=audioCtx.createOscillator();const gainNode=audioCtx.createGain();gainNode.gain.value=0.001;// Praticamente silencioso\noscillator.connect(gainNode);gainNode.connect(audioCtx.destination);oscillator.start(0);oscillator.stop(0.05);// Apenas 50ms\nreturn new Promise(resolve=>{setTimeout(()=>{audioCtx.close().then(()=>{console.log('[DEBUG] Áudio desbloqueado no iOS');resolve();});},100);});}catch(error){console.warn('[WARN] Erro ao desbloquear áudio:',error);return Promise.resolve();}};// Função aprimorada para lidar com URLs de áudio no iOS\nconst getFullUrl=url=>{if(!url)return\"\";// Verificar se o URL já é um objeto blob\nif(url.startsWith('blob:')){console.log('[DEBUG] URL já é um Blob URL:',url);return url;}// Se a URL já começa com http ou https, retornar como está com timestamp para iOS\nif(url.startsWith('http://')||url.startsWith('https://')){// Para iOS, adicionar parâmetro de timestamp para evitar cache\nif(isIOSDevice){const cacheBuster=\"t=\".concat(new Date().getTime());return\"\".concat(url).concat(url.includes('?')?'&':'?').concat(cacheBuster);}return url;}// Se a URL é relativa, adicionar o endereço do backend\nconst BACKEND_URL=process.env.REACT_APP_BACKEND_URL||window.location.origin;// Se começa com '/', removemos a barra para evitar duplicação\nconst cleanUrl=url.startsWith('/')?url.substring(1):url;// Verificar se já contém o prefixo público antes de adicioná-lo\nconst urlWithPublic=cleanUrl.startsWith('public/')?cleanUrl:\"public/\".concat(cleanUrl);// Construir a URL completa\nlet fullUrl=\"\".concat(BACKEND_URL,\"/\").concat(urlWithPublic);// Para iOS, adicionar parâmetro de timestamp para evitar cache\nif(isIOSDevice){const cacheBuster=\"t=\".concat(new Date().getTime());fullUrl=\"\".concat(fullUrl,\"?\").concat(cacheBuster);}console.log('[DEBUG] URL de áudio processada:',{original:url,final:fullUrl});return fullUrl;};// Função especializada para reproduzir áudio no iOS\nconst playAudioInIOS=async audioUrl=>{if(!audioUrl){console.error('[ERROR] URL inválida para reprodução no iOS');throw new Error('URL inválida para reprodução');}console.log('[DEBUG] Iniciando reprodução especializada para iOS:',audioUrl);// Desbloquear API de áudio\nawait unlockAudioOnIOS();// Sempre criar um novo elemento para evitar problemas de cache no iOS\nconst newAudio=new Audio();// Configurar atributos especiais para iOS\nnewAudio.setAttribute('playsinline','true');newAudio.setAttribute('webkit-playsinline','true');newAudio.crossOrigin='anonymous';newAudio.preload='auto';newAudio.volume=1.0;// Adicionar timestamp para evitar cache\nconst timeStampedUrl=audioUrl.includes('?')?\"\".concat(audioUrl,\"&_iosr=\").concat(Date.now()):\"\".concat(audioUrl,\"?_iosr=\").concat(Date.now());return new Promise((resolve,reject)=>{// Função para tentar iniciar reprodução\nconst attemptPlay=async()=>{try{// Importante: Interagir com o elemento antes de tentar reproduzir\n// Isso é uma \"dica\" para o iOS de que a reprodução é resultado de ação do usuário\nnewAudio.load();// Aguardar um momento para garantir que o iOS prepare o elemento\nawait new Promise(r=>setTimeout(r,100));// Iniciar reprodução\nawait newAudio.play();console.log('[DEBUG] Reprodução iniciada com sucesso no iOS');resolve(newAudio);}catch(error){console.error('[ERROR] Falha na tentativa de reprodução:',error);reject(error);}};// Configurar manipuladores de eventos\nnewAudio.oncanplay=attemptPlay;newAudio.onloadeddata=()=>{console.log('[DEBUG] Dados de áudio carregados no iOS, duração:',newAudio.duration);};newAudio.onerror=error=>{console.error('[ERROR] Falha ao carregar áudio no iOS:',newAudio.error?newAudio.error.code+' - '+newAudio.error.message:'Erro desconhecido');reject(new Error(\"Erro ao carregar \\xE1udio: \".concat(newAudio.error?newAudio.error.code:'desconhecido')));};// Definir a URL e iniciar carregamento\nnewAudio.src=timeStampedUrl;newAudio.load();// Timeout para caso oncanplay nunca seja disparado\nsetTimeout(()=>{// Se ainda não resolvido, tentar reproduzir diretamente\nif(newAudio.readyState>=2){attemptPlay();}else if(newAudio.readyState<2){console.warn('[WARN] Timeout ao aguardar carregamento no iOS, tentando mesmo assim');attemptPlay();}},2000);});};// Função para tentar todas as abordagens possíveis de reprodução no iOS\nconst tryAllIOSPlaybackMethods=async audioUrl=>{const errors=[];// Método 1: Reprodução especializada\ntry{console.log('[DEBUG] iOS - Tentativa 1: Reprodução especializada');const audio=await playAudioInIOS(audioUrl);return audio;}catch(error){errors.push(\"M\\xE9todo 1: \".concat(error.message));console.error('[ERROR] Falha no método 1:',error);}// Método 2: Elemento de áudio com atributos otimizados\ntry{console.log('[DEBUG] iOS - Tentativa 2: Elemento de áudio com atributos otimizados');// Desbloquear API de áudio novamente\nawait unlockAudioOnIOS();const tempAudio=new Audio();// Configurações extras\ntempAudio.setAttribute('playsinline','true');tempAudio.setAttribute('webkit-playsinline','true');tempAudio.setAttribute('controls','true');tempAudio.muted=false;tempAudio.autoplay=false;tempAudio.volume=1.0;// URL com timestamp adicional\nconst cacheBustUrl=\"\".concat(audioUrl.split('?')[0],\"?_iost2=\").concat(Date.now());tempAudio.src=cacheBustUrl;// Carregar o áudio explicitamente\ntempAudio.load();// Esperar que o iOS carregue os metadados\nawait new Promise(resolve=>{tempAudio.onloadedmetadata=resolve;// Timeout de segurança\nsetTimeout(resolve,1000);});// Esperar um pouco antes de reproduzir\nawait new Promise(resolve=>setTimeout(resolve,300));// Tentar reproduzir\nawait tempAudio.play();console.log('[DEBUG] Método 2 funcionou!');return tempAudio;}catch(error){errors.push(\"M\\xE9todo 2: \".concat(error.message));console.error('[ERROR] Falha no método 2:',error);}// Método 3: Abordagem com evento de click simulado\ntry{console.log('[DEBUG] iOS - Tentativa 3: Abordagem com evento de touch simulado');// Criar um elemento invisível para capturar interação do usuário\nconst touchTarget=document.createElement('button');touchTarget.style.position='fixed';touchTarget.style.top='-9999px';touchTarget.style.left='-9999px';touchTarget.textContent='Habilitar áudio';document.body.appendChild(touchTarget);// Simular interação do usuário\ntouchTarget.click();// Criar novo elemento de áudio após interação\nconst finalAudio=new Audio();finalAudio.setAttribute('playsinline','true');finalAudio.setAttribute('webkit-playsinline','true');finalAudio.crossOrigin='anonymous';finalAudio.src=\"\".concat(audioUrl.split('?')[0],\"?_iosfinal=\").concat(Date.now());finalAudio.load();// Esperar um momento e tentar reproduzir\nawait new Promise(resolve=>setTimeout(resolve,500));await finalAudio.play();// Remover elemento temporário\ndocument.body.removeChild(touchTarget);console.log('[DEBUG] Método 3 funcionou!');return finalAudio;}catch(error){errors.push(\"M\\xE9todo 3: \".concat(error.message));console.error('[ERROR] Falha no método 3:',error);}// Se chegou aqui, todas as tentativas falharam\nthrow new Error(\"Todas as tentativas para iOS falharam: \".concat(errors.join(', ')));};export default function ChatAudioPlayer(_ref){let{audioUrl,duration,isRight}=_ref;const classes=useStyles();const[isPlaying,setIsPlaying]=useState(false);const[currentTime,setCurrentTime]=useState(0);const[audioDuration,setAudioDuration]=useState(duration||0);const[metadataLoaded,setMetadataLoaded]=useState(false);const[loadingFailed,setLoadingFailed]=useState(false);const[retryCount,setRetryCount]=useState(0);const[errorMessage,setErrorMessage]=useState(null);const audioRef=useRef(null);const progressInterval=useRef(null);const audioContext=useRef(null);// Validar duração para garantir valor numérico válido\nconst validateDuration=value=>{// Verificar se o valor é numérico e finito\nif(value===undefined||value===null||!isFinite(value)||isNaN(value)||value<=0){return 0;}return parseFloat(value);};// Atualizar duração quando fornecida como prop\nuseEffect(()=>{const validDuration=validateDuration(duration);if(validDuration>0){console.log(\"[DEBUG] Dura\\xE7\\xE3o v\\xE1lida recebida: \".concat(validDuration,\"s\"));setAudioDuration(validDuration);setMetadataLoaded(true);}else if(audioDuration>0){// Se já temos uma duração válida no estado, considerar os metadados como carregados\nsetMetadataLoaded(true);}},[duration,audioDuration]);// Limpar recursos ao desmontar\nuseEffect(()=>{return()=>{if(progressInterval.current){clearInterval(progressInterval.current);}if(audioRef.current){audioRef.current.pause();}// Limpar o contexto de áudio\nif(audioContext.current){try{audioContext.current.close();}catch(e){console.warn('[WARN] Erro ao fechar contexto de áudio:',e);}}};},[]);// Função para iniciar monitoramento da reprodução\nconst startPlaybackMonitoring=audioElement=>{if(!audioElement)return;// Configurar monitoramento de progresso\nclearInterval(progressInterval.current);progressInterval.current=setInterval(()=>{try{if(audioElement&&!audioElement.paused){setCurrentTime(audioElement.currentTime||0);}}catch(error){console.warn('[WARN] Erro ao atualizar progresso:',error);}},100);// Adicionar listener para quando o áudio terminar\naudioElement.onended=()=>{console.log('[DEBUG] Reprodução finalizada');setIsPlaying(false);setCurrentTime(0);clearInterval(progressInterval.current);};};// Função melhorada para reprodução de áudio, com tratamento especial para iOS\nconst togglePlayback=async()=>{// Se estiver tocando, apenas pause\nif(isPlaying){console.log('[DEBUG] Pausando reprodução');if(audioRef.current){try{audioRef.current.pause();clearInterval(progressInterval.current);}catch(error){console.warn('[WARN] Erro ao pausar áudio:',error);}setIsPlaying(false);}return;}// Reset estado de erro se estiver tentando novamente\nsetLoadingFailed(false);setErrorMessage(null);// Incrementar contador de tentativas\nsetRetryCount(prev=>prev+1);console.log(\"[DEBUG] Iniciando reprodu\\xE7\\xE3o (tentativa #\".concat(retryCount+1,\") com URL:\"),audioUrl);try{// Desbloquear áudio para todos os navegadores\nawait unlockAudioOnIOS();// Estratégia específica para iOS\nif(isIOSDevice){console.log('[DEBUG] Usando estratégia específica para iOS');// Processar a URL adequadamente\nconst fullUrl=getFullUrl(audioUrl);try{// Tentar todas as abordagens possíveis\nconst iosAudio=await tryAllIOSPlaybackMethods(fullUrl);// Se chegou aqui, conseguimos reproduzir\nconsole.log('[DEBUG] Reprodução iniciada com sucesso no iOS');// Atualizar referência\naudioRef.current=iosAudio;// Configurar monitoramento\nsetIsPlaying(true);startPlaybackMonitoring(iosAudio);// Obter a duração exata se disponível\nif(iosAudio.duration&&isFinite(iosAudio.duration)&&iosAudio.duration>0){setAudioDuration(iosAudio.duration);setMetadataLoaded(true);}}catch(iosError){console.error('[ERROR] Todas as tentativas falharam para iOS:',iosError);setErrorMessage(\"Toque para ativar áudio\");setLoadingFailed(true);setIsPlaying(false);// Mostrar instruções específicas para Safari no iOS\nwindow.alert(\"Para reproduzir áudio no Safari iOS:\\n\\n\"+\"1. Toque no botão de play novamente\\n\"+\"2. Clique em qualquer lugar da tela quando solicitado\\n\"+\"3. Em seguida, toque no botão de play mais uma vez\");}}else{// Abordagem para navegadores não-iOS\nconsole.log('[DEBUG] Usando abordagem padrão para não-iOS');// Inicializar o elemento de áudio se necessário\nif(!audioRef.current){audioRef.current=new Audio();}// Reset\naudioRef.current.currentTime=0;// URL completa\nconst fullUrl=getFullUrl(audioUrl);// Configurar e carregar\naudioRef.current.src=fullUrl;audioRef.current.load();// Tentar reproduzir\nawait audioRef.current.play();console.log('[DEBUG] Reprodução iniciada com sucesso em navegador não-iOS');// Atualizar estado e configurar monitoramento\nsetIsPlaying(true);startPlaybackMonitoring(audioRef.current);}}catch(error){console.error('[ERROR] Falha ao reproduzir áudio:',error);// Mostrar mensagem de erro mas permitir novas tentativas\nsetIsPlaying(false);setLoadingFailed(true);setErrorMessage(isIOSDevice?\"Toque para ativar áudio\":\"Erro: Tente novamente\");}};return/*#__PURE__*/React.createElement(Box,{className:classes.audioContainer,style:{alignSelf:isRight?\"flex-end\":\"flex-start\"}},/*#__PURE__*/React.createElement(\"div\",{className:classes.playerControls},/*#__PURE__*/React.createElement(IconButton,{className:classes.playButton,onClick:togglePlayback,disabled:false// Nunca desabilitar para permitir novas tentativas\n,size:\"small\"},isPlaying?/*#__PURE__*/React.createElement(PauseIcon,{fontSize:\"small\"}):/*#__PURE__*/React.createElement(PlayArrowIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"div\",{className:classes.progressContainer},/*#__PURE__*/React.createElement(LinearProgress,{className:classes.progressBar,variant:\"determinate\",value:audioDuration>0?currentTime/audioDuration*100:0}),/*#__PURE__*/React.createElement(\"div\",{className:classes.timeInfo},/*#__PURE__*/React.createElement(Typography,{className:classes.timeText,variant:\"caption\"},formatTime(currentTime)),/*#__PURE__*/React.createElement(Typography,{className:classes.timeText,variant:\"caption\"},loadingFailed?errorMessage||\"Toque novamente\":!metadataLoaded?\"Carregando...\":formatTime(audioDuration))))));}","map":null,"metadata":{},"sourceType":"module"}