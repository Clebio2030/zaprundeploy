{"ast":null,"code":"import React,{useState,useRef,useEffect}from'react';import{IconButton,makeStyles,CircularProgress,Paper,Typography,Box,LinearProgress,Tooltip}from'@material-ui/core';import MicIcon from'@material-ui/icons/Mic';import StopIcon from'@material-ui/icons/Stop';import DeleteIcon from'@material-ui/icons/Delete';import SendIcon from'@material-ui/icons/Send';import PauseIcon from'@material-ui/icons/Pause';import PlayArrowIcon from'@material-ui/icons/PlayArrow';const useStyles=makeStyles(theme=>({root:{display:'flex',alignItems:'center'},recordingButton:{color:theme.palette.error.main,animation:'$pulse 1.5s infinite'},'@keyframes pulse':{'0%':{boxShadow:'0 0 0 0 rgba(244, 67, 54, 0.4)'},'70%':{boxShadow:'0 0 0 10px rgba(244, 67, 54, 0)'},'100%':{boxShadow:'0 0 0 0 rgba(244, 67, 54, 0)'}},// Estilo para a barra de gravação estilo WhatsApp\nrecorderBar:{display:'flex',alignItems:'center',backgroundColor:'rgba(30, 30, 30, 0.95)',width:'100%',padding:theme.spacing(0.5,1),borderRadius:24,boxShadow:'0px 2px 4px rgba(0, 0, 0, 0.15)',border:'1px solid rgba(255, 255, 255, 0.1)'},timerText:{color:'#FFFFFF',fontSize:'0.9rem',fontWeight:'bold',marginLeft:theme.spacing(1),marginRight:theme.spacing(1)},waveform:{flex:1,display:'flex',alignItems:'center',justifyContent:'center',height:24,margin:theme.spacing(0,1),backgroundColor:'rgba(255, 255, 255, 0.1)',borderRadius:12,padding:theme.spacing(0.5)},waveformCanvas:{width:'100%',height:'100%'},sendButton:{backgroundColor:'#00A884',color:'white','&:hover':{backgroundColor:'#008F72'},borderRadius:'50%',padding:8,boxShadow:'0px 2px 5px rgba(0, 0, 0, 0.2)',margin:theme.spacing(0,0.5),border:'2px solid rgba(255, 255, 255, 0.3)',transition:'all 0.2s ease-in-out','&:disabled':{backgroundColor:'rgba(0, 168, 132, 0.6)',color:'rgba(255, 255, 255, 0.7)'}},pauseResumeButton:{color:'white',padding:8},trashButton:{color:'white',padding:8},recordingDot:{width:8,height:8,borderRadius:'50%',backgroundColor:'red',marginRight:theme.spacing(1),animation:'$blink 1s infinite'},'@keyframes blink':{'0%':{opacity:1},'50%':{opacity:0.3},'100%':{opacity:1}},reviewContainer:{width:'100%',display:'flex',alignItems:'center',padding:theme.spacing(1.2),backgroundColor:'rgba(255, 255, 255, 0.9)',borderRadius:24,boxShadow:'0 2px 8px rgba(0, 0, 0, 0.08)',border:'none',transition:'all 0.2s ease-in-out','&:hover':{boxShadow:'0 3px 10px rgba(0, 0, 0, 0.12)'}},reviewAudioInfo:{display:'flex',flexDirection:'column',flex:1,marginLeft:theme.spacing(1),marginRight:theme.spacing(1)},progressBar:{width:'100%',height:6,marginTop:6,borderRadius:3,backgroundColor:'rgba(0, 0, 0, 0.05)','& .MuiLinearProgress-bar':{backgroundColor:'#00A884',borderRadius:3}},audioLength:{fontSize:'0.7rem',color:theme.palette.text.secondary,marginTop:2,display:'flex',justifyContent:'space-between'}}));// Componente de gravação de áudio estilo WhatsApp\nconst ChatAudioRecorder=_ref=>{let{onAudioRecorded,disabled=false}=_ref;const classes=useStyles();const[isRecording,setIsRecording]=useState(false);const[recordingTime,setRecordingTime]=useState(0);const[recordedAudio,setRecordedAudio]=useState(null);const[isPlaying,setIsPlaying]=useState(false);const[isUploading,setIsUploading]=useState(false);const[uploadProgress,setUploadProgress]=useState(0);const[isPaused,setIsPaused]=useState(false);const[currentTime,setCurrentTime]=useState(0);const[audioDuration,setAudioDuration]=useState(0);const[isLoadingAudio,setIsLoadingAudio]=useState(false);// Refs\nconst mediaRecorderRef=useRef(null);const audioChunksRef=useRef([]);const audioStreamRef=useRef(null);const timerRef=useRef(null);const canvasRef=useRef(null);const audioContextRef=useRef(null);const analyserRef=useRef(null);const animationRef=useRef(null);const audioRef=useRef(null);const progressIntervalRef=useRef(null);// Formatação de tempo (mm:ss)\nconst formatTime=seconds=>{// Verificar se o valor é válido\nif(seconds===undefined||seconds===null||isNaN(seconds)||!isFinite(seconds)){return\"00:00\";}// Garantir que é um número e limitar a valores razoáveis\nconst safeSeconds=Math.min(Math.max(0,Number(seconds)),3600);// Limitar a 1 hora\nconst mins=Math.floor(safeSeconds/60);const secs=Math.floor(safeSeconds%60);return\"\".concat(mins.toString().padStart(2,'0'),\":\").concat(secs.toString().padStart(2,'0'));};// Função para iniciar o visualizador de áudio\nconst startVisualizer=()=>{if(!canvasRef.current||!analyserRef.current)return;const canvas=canvasRef.current;const canvasCtx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;analyserRef.current.fftSize=256;const bufferLength=analyserRef.current.frequencyBinCount;const dataArray=new Uint8Array(bufferLength);const draw=()=>{if(!isRecording||isPaused)return;animationRef.current=requestAnimationFrame(draw);analyserRef.current.getByteFrequencyData(dataArray);canvasCtx.clearRect(0,0,width,height);// Desenhar forma de onda estilo WhatsApp\nconst barWidth=2;const gap=1;const barCount=Math.floor(width/(barWidth+gap));const step=Math.floor(bufferLength/barCount)||1;for(let i=0;i<barCount;i++){const dataIndex=i*step;if(dataIndex>=bufferLength)break;// Usar a média de alguns valores para suavizar\nlet sum=0;let count=0;for(let j=0;j<step&&dataIndex+j<bufferLength;j++){sum+=dataArray[dataIndex+j];count++;}const average=count>0?sum/count:0;const barHeight=Math.max(1,average/255*height);const x=i*(barWidth+gap);const y=(height-barHeight)/2;// Cor cinza claro para as barras de visualização\ncanvasCtx.fillStyle='#CCCCCC';canvasCtx.fillRect(x,y,barWidth,barHeight);}};draw();};// Função para reproduzir o áudio gravado\nconst playRecordedAudio=()=>{if(!audioRef.current||!recordedAudio||isLoadingAudio)return;if(isPlaying){audioRef.current.pause();clearInterval(progressIntervalRef.current);setIsPlaying(false);}else{audioRef.current.currentTime=0;// Verificar se a URL do áudio ainda é válida\nif(recordedAudio.url){console.log('[DEBUG] Reproduzindo áudio gravado:',recordedAudio.url);// Adicionar tratamento de erros\naudioRef.current.onerror=e=>{console.error('[ERROR] Falha ao reproduzir áudio:',e);setIsPlaying(false);setIsLoadingAudio(false);window.alert('Houve um erro ao reproduzir o áudio. Tente gravar novamente.');};// Adicionar tratamento para verificar se o formato é suportado\naudioRef.current.onloadstart=()=>{console.log('[DEBUG] Carregamento de áudio iniciado');};setIsLoadingAudio(true);audioRef.current.play().then(()=>{console.log('[DEBUG] Reprodução iniciada com sucesso');setIsPlaying(true);setIsLoadingAudio(false);// Atualizar o progresso da reprodução\nprogressIntervalRef.current=setInterval(()=>{setCurrentTime(audioRef.current.currentTime);},100);}).catch(error=>{console.error('[ERROR] Erro ao iniciar reprodução:',error);setIsPlaying(false);setIsLoadingAudio(false);window.alert('Não foi possível reproduzir o áudio. O formato pode não ser suportado.');});}else{console.error('[ERROR] URL de áudio inválida');window.alert('URL de áudio inválida. Tente gravar novamente.');return;}}};// Função para enviar o áudio gravado\nconst sendRecordedAudio=()=>{if(!recordedAudio||!recordedAudio.blob){console.error('[ERROR] Nenhum áudio disponível para envio');return;}if(recordedAudio.blob.size===0){console.error('[ERROR] Blob de áudio vazio');window.alert('O arquivo de áudio está vazio. Tente gravar novamente.');return;}try{// Verificar se estamos em um dispositivo iOS\nconst isIOS=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream;console.log(\"[DEBUG] Dispositivo iOS detectado: \".concat(isIOS));// Determinar a extensão com base no tipo MIME\nlet extension='webm';let mimeType=recordedAudio.mimeType||recordedAudio.blob.type;console.log('[DEBUG] MIME type original para envio:',mimeType);// Para iOS, preferir formatos mais compatíveis\nif(isIOS){// iOS tem melhor compatibilidade com MP4/AAC ou MP3\nif(MediaRecorder.isTypeSupported('audio/mp4')){mimeType='audio/mp4';extension='mp4';}else if(MediaRecorder.isTypeSupported('audio/mp3')||MediaRecorder.isTypeSupported('audio/mpeg')){mimeType=MediaRecorder.isTypeSupported('audio/mp3')?'audio/mp3':'audio/mpeg';extension='mp3';}}else{// Mapear o tipo MIME para a extensão correta\nif(mimeType.includes('mp3')||mimeType.includes('mpeg')){extension='mp3';}else if(mimeType.includes('ogg')){extension='ogg';}else if(mimeType.includes('wav')){extension='wav';}else if(mimeType.includes('mp4')){extension='mp4';}else if(mimeType.includes('webm')){extension='webm';}}console.log('[DEBUG] Extensão determinada:',extension);console.log('[DEBUG] MIME type final:',mimeType);// Criar arquivo para envio com o nome usando timestamp para evitar conflitos\nconst fileName=\"audio_\".concat(Date.now(),\".\").concat(extension);const audioFile=new File([recordedAudio.blob],fileName,{type:mimeType});console.log(\"[DEBUG] Arquivo de \\xE1udio criado: \".concat(audioFile.name,\", tipo: \").concat(audioFile.type,\", \").concat(audioFile.size,\" bytes\"));// Iniciar upload\nsetIsUploading(true);// Callback para o componente pai\nonAudioRecorded(audioFile,progress=>{setUploadProgress(progress);},()=>{setIsUploading(false);// Limpar gravação após envio\nif(recordedAudio&&recordedAudio.url){URL.revokeObjectURL(recordedAudio.url);}setRecordedAudio(null);setRecordingTime(0);setCurrentTime(0);});}catch(error){console.error('[ERROR] Falha ao processar arquivo de áudio:',error);window.alert('Erro ao processar o áudio. Tente novamente.');setIsUploading(false);}};// Função para iniciar gravação\nconst startRecording=async()=>{console.log('[DEBUG] Iniciando gravação');try{// Revogar URL de qualquer gravação anterior\nif(recordedAudio&&recordedAudio.url){URL.revokeObjectURL(recordedAudio.url);setRecordedAudio(null);}// Verificar se estamos em um dispositivo iOS\nconst isIOS=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream;console.log(\"[DEBUG] Dispositivo iOS detectado: \".concat(isIOS));// Solicitar permissão para o microfone com configurações otimizadas\nconst stream=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true,autoGainControl:true}});console.log('[DEBUG] Permissão de microfone concedida');audioStreamRef.current=stream;// Configurar o contexto de áudio para visualização\nconst audioContext=new(window.AudioContext||window.webkitAudioContext)();audioContextRef.current=audioContext;const analyser=audioContext.createAnalyser();analyserRef.current=analyser;const source=audioContext.createMediaStreamSource(stream);source.connect(analyser);// Redefinir o array de chunks\naudioChunksRef.current=[];// Testar formatos suportados - em ordem de preferência\n// Para iOS, priorizar formatos compatíveis\nconst tryFormats=isIOS?['audio/mp4','audio/mp4;codecs=mp4a','audio/mpeg','audio/mp3','audio/aac','audio/ogg;codecs=opus','audio/webm;codecs=opus','audio/webm','audio/ogg']:['audio/webm;codecs=opus','audio/mp4;codecs=mp4a','audio/ogg;codecs=opus','audio/webm','audio/ogg','audio/mp3','audio/mpeg'];let selectedMimeType='';// Verificar formatos compatíveis\nfor(const format of tryFormats){if(MediaRecorder.isTypeSupported(format)){selectedMimeType=format;console.log(\"[DEBUG] Formato suportado encontrado: \".concat(format));break;}}// Se nenhum formato específico for suportado, usar o padrão\nif(!selectedMimeType){console.warn('[WARN] Nenhum formato específico é suportado. Usando padrão do navegador.');selectedMimeType='';}console.log(\"[DEBUG] Usando formato de grava\\xE7\\xE3o: \".concat(selectedMimeType||'padrão do navegador'));// Criar MediaRecorder com configurações otimizadas\nconst recorder=new MediaRecorder(stream,{mimeType:selectedMimeType,audioBitsPerSecond:128000// 128kbps para boa qualidade\n});mediaRecorderRef.current=recorder;// Configurar eventos para o MediaRecorder\nrecorder.addEventListener('dataavailable',event=>{if(event.data.size>0){audioChunksRef.current.push(event.data);}});recorder.addEventListener('start',()=>{console.log('[DEBUG] Gravação iniciada');setIsRecording(true);setIsPaused(false);// Iniciar timer\ntimerRef.current=setInterval(()=>{setRecordingTime(prev=>prev+1);},1000);// Iniciar visualizador\nif(canvasRef.current){startVisualizer();}});recorder.addEventListener('stop',handleRecordingStopped);recorder.addEventListener('error',event=>{console.error('[ERROR] Erro no MediaRecorder:',event);window.alert('Erro na gravação. Verifique o microfone.');setIsRecording(false);});// Iniciar gravação\nrecorder.start(1000);// Captura chunks a cada 1 segundo\n}catch(error){console.error('[ERROR] Erro ao iniciar gravação:',error);window.alert('Erro ao acessar o microfone. Verifique as permissões do navegador.');}};// Manipulador de interrupção da gravação\nconst handleRecordingStopped=()=>{console.log('[DEBUG] Gravação parada. Total de chunks:',audioChunksRef.current.length);// Parar o stream de áudio\nif(audioStreamRef.current){audioStreamRef.current.getTracks().forEach(track=>track.stop());}// Verificar se capturamos algum dado\nif(!audioChunksRef.current||audioChunksRef.current.length===0){console.error('[ERROR] Nenhum dado de áudio capturado');window.alert('Não foi possível capturar áudio. Verifique o microfone.');return;}// Obter o tipo MIME usado na gravação\nconst mimeType=mediaRecorderRef.current?mediaRecorderRef.current.mimeType:'audio/webm';console.log('[DEBUG] MimeType usado na gravação:',mimeType);// Criar o blob de áudio com o tipo MIME correto\nconst audioBlob=new Blob(audioChunksRef.current,{type:mimeType});console.log(\"[DEBUG] Blob de \\xE1udio criado: \".concat(audioBlob.size,\" bytes, tipo: \").concat(audioBlob.type));if(audioBlob.size===0){console.error('[ERROR] Blob de áudio vazio');window.alert('Erro na gravação. Tente novamente.');return;}// Guardar a duração da gravação (verificar se é válida)\nconst finalDuration=recordingTime>0?recordingTime:0;console.log(\"[DEBUG] Dura\\xE7\\xE3o da grava\\xE7\\xE3o: \".concat(finalDuration,\" segundos\"));// Criar URL do blob para reprodução\nconst audioUrl=URL.createObjectURL(audioBlob);// Salvar áudio gravado imediatamente com a duração da gravação\nsetAudioDuration(finalDuration);setRecordedAudio({blob:audioBlob,url:audioUrl,duration:finalDuration,mimeType:audioBlob.type});// Inicializar o elemento de áudio para reprodução\nif(!audioRef.current){audioRef.current=new Audio();}audioRef.current.src=audioUrl;audioRef.current.load();// Tentar obter a duração exata do áudio\ntry{const tempAudio=new Audio(audioUrl);tempAudio.addEventListener('loadedmetadata',()=>{const actualDuration=tempAudio.duration;console.log(\"[DEBUG] Dura\\xE7\\xE3o real do \\xE1udio: \".concat(actualDuration,\" segundos\"));// Verificar se a duração é válida antes de usar\nif(!isNaN(actualDuration)&&isFinite(actualDuration)&&actualDuration>0){setAudioDuration(actualDuration);// Atualizar objeto de áudio com a duração correta\nsetRecordedAudio(prev=>({...prev,duration:actualDuration}));}});// Adicionar tratamento de erro\ntempAudio.addEventListener('error',error=>{console.error('[ERROR] Erro ao carregar metadados do áudio:',error);});}catch(error){console.warn('[WARN] Erro ao tentar obter duração do áudio:',error);// Continuar usando a duração da gravação\n}};// Função para pausar/continuar a gravação\nconst togglePauseRecording=()=>{if(!mediaRecorderRef.current)return;if(isPaused){// Continuar gravação\nif(mediaRecorderRef.current.state==='paused'){mediaRecorderRef.current.resume();}// Reiniciar timer\ntimerRef.current=setInterval(()=>{setRecordingTime(prevTime=>prevTime+1);},1000);// Reiniciar visualizador\nstartVisualizer();setIsPaused(false);}else{// Pausar gravação\nif(mediaRecorderRef.current.state==='recording'){mediaRecorderRef.current.pause();}// Pausar timer\nif(timerRef.current){clearInterval(timerRef.current);}// Pausar visualizador\nif(animationRef.current){cancelAnimationFrame(animationRef.current);}setIsPaused(true);}};// Função para parar a gravação\nconst stopRecording=()=>{if(mediaRecorderRef.current&&mediaRecorderRef.current.state!=='inactive'){console.log('[DEBUG] Parando gravação');mediaRecorderRef.current.stop();// Limpar timer\nif(timerRef.current){clearInterval(timerRef.current);timerRef.current=null;}// Parar visualizador\nif(animationRef.current){cancelAnimationFrame(animationRef.current);animationRef.current=null;}setIsRecording(false);setIsPaused(false);}};// Função para cancelar a gravação\nconst cancelRecording=()=>{console.log('[DEBUG] Cancelando gravação');// Parar a gravação se estiver ativa\nif(mediaRecorderRef.current&&mediaRecorderRef.current.state!=='inactive'){mediaRecorderRef.current.stop();// Parar o stream de áudio\nif(audioStreamRef.current){audioStreamRef.current.getTracks().forEach(track=>track.stop());}}// Limpar timer\nif(timerRef.current){clearInterval(timerRef.current);timerRef.current=null;}// Parar visualizador\nif(animationRef.current){cancelAnimationFrame(animationRef.current);animationRef.current=null;}// Resetar estado\nsetIsRecording(false);setIsPaused(false);setRecordingTime(0);// Limpar gravação se existir\nif(recordedAudio&&recordedAudio.url){URL.revokeObjectURL(recordedAudio.url);setRecordedAudio(null);}};// Eventos de áudio\nuseEffect(()=>{if(audioRef.current&&recordedAudio){// Carregar metadados do áudio quando disponível\naudioRef.current.onloadedmetadata=()=>{const audioElementDuration=audioRef.current.duration;if(!isNaN(audioElementDuration)&&isFinite(audioElementDuration)&&audioElementDuration>0){console.log(\"[DEBUG] Dura\\xE7\\xE3o do \\xE1udio carregada: \".concat(audioElementDuration,\"s\"));setAudioDuration(audioElementDuration);// Atualizar objeto de áudio com a duração correta\nsetRecordedAudio(prev=>({...prev,duration:audioElementDuration}));}else{console.warn('[WARN] Duração inválida do elemento de áudio:',audioElementDuration);}};audioRef.current.onended=()=>{setIsPlaying(false);setCurrentTime(0);clearInterval(progressIntervalRef.current);};}return()=>{if(progressIntervalRef.current){clearInterval(progressIntervalRef.current);}};},[recordedAudio]);// Ajustar o canvas quando necessário\nuseEffect(()=>{if(isRecording&&canvasRef.current){setTimeout(()=>{canvasRef.current.width=canvasRef.current.offsetWidth;canvasRef.current.height=canvasRef.current.offsetHeight;if(!isPaused)startVisualizer();},100);}},[isRecording,isPaused]);// Limpar recursos quando o componente for desmontado\nuseEffect(()=>{return()=>{cancelRecording();if(recordedAudio&&recordedAudio.url){URL.revokeObjectURL(recordedAudio.url);}if(progressIntervalRef.current){clearInterval(progressIntervalRef.current);}};},[]);// Renderizar a barra de gravação estilo WhatsApp\nif(isRecording){return/*#__PURE__*/React.createElement(\"div\",{className:classes.recorderBar},/*#__PURE__*/React.createElement(IconButton,{className:classes.trashButton,onClick:cancelRecording},/*#__PURE__*/React.createElement(DeleteIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"div\",{className:classes.recordingDot}),/*#__PURE__*/React.createElement(Typography,{className:classes.timerText},formatTime(recordingTime)),/*#__PURE__*/React.createElement(\"div\",{className:classes.waveform},/*#__PURE__*/React.createElement(\"canvas\",{ref:canvasRef,className:classes.waveformCanvas})),/*#__PURE__*/React.createElement(IconButton,{className:classes.pauseResumeButton,onClick:togglePauseRecording},isPaused?/*#__PURE__*/React.createElement(PlayArrowIcon,{fontSize:\"small\"}):/*#__PURE__*/React.createElement(PauseIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(IconButton,{className:classes.sendButton,onClick:stopRecording,disabled:recordingTime<1},/*#__PURE__*/React.createElement(SendIcon,{fontSize:\"small\"})));}// Renderizar o player de revisão se um áudio foi gravado\nif(recordedAudio){// Garantir que a duração seja sempre um número válido\nconst displayDuration=!isNaN(audioDuration)&&isFinite(audioDuration)&&audioDuration>0?audioDuration:!isNaN(recordedAudio.duration)&&isFinite(recordedAudio.duration)&&recordedAudio.duration>0?recordedAudio.duration:0;// Calcular a porcentagem de progresso de forma segura\nconst progressPercentage=isPlaying&&displayDuration>0?Math.min(100,Math.max(0,currentTime/displayDuration*100)):0;return/*#__PURE__*/React.createElement(\"div\",{className:classes.reviewContainer},/*#__PURE__*/React.createElement(IconButton,{onClick:cancelRecording,size:\"small\"},/*#__PURE__*/React.createElement(DeleteIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"div\",{className:classes.reviewAudioInfo},/*#__PURE__*/React.createElement(\"div\",{style:{display:'flex',alignItems:'center'}},/*#__PURE__*/React.createElement(IconButton,{onClick:playRecordedAudio,size:\"small\"},isPlaying?/*#__PURE__*/React.createElement(PauseIcon,{fontSize:\"small\"}):/*#__PURE__*/React.createElement(PlayArrowIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(Typography,{variant:\"caption\"},\"\\xC1udio gravado\")),/*#__PURE__*/React.createElement(LinearProgress,{className:classes.progressBar,variant:\"determinate\",value:progressPercentage}),/*#__PURE__*/React.createElement(\"div\",{className:classes.audioLength},/*#__PURE__*/React.createElement(\"span\",null,formatTime(isPlaying?currentTime:0)),/*#__PURE__*/React.createElement(\"span\",null,formatTime(displayDuration)))),/*#__PURE__*/React.createElement(IconButton,{className:classes.sendButton,onClick:sendRecordedAudio,disabled:isUploading,size:\"small\"},isUploading?/*#__PURE__*/React.createElement(CircularProgress,{size:20,color:\"inherit\"}):/*#__PURE__*/React.createElement(SendIcon,{fontSize:\"small\"})),/*#__PURE__*/React.createElement(\"audio\",{ref:audioRef,src:recordedAudio.url,style:{display:'none'},preload:\"metadata\"}));}// Renderizar apenas o botão de microfone\nreturn/*#__PURE__*/React.createElement(Tooltip,{title:\"Gravar \\xE1udio\"},/*#__PURE__*/React.createElement(\"span\",{className:classes.root},/*#__PURE__*/React.createElement(IconButton,{color:\"primary\",\"aria-label\":\"gravar \\xE1udio\",onClick:startRecording,disabled:disabled||isUploading},/*#__PURE__*/React.createElement(MicIcon,null))));};export default ChatAudioRecorder;","map":null,"metadata":{},"sourceType":"module"}